/**
 * @file acim_freq_ctrl.h
 * @date 2015-10-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * ACIM_FREQ_CTRL v4.0.7 - Supports frequency control- constant V/f Control\nfor the AC induction motor (ACIM).
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version
 *
 * 2015-06-20:
 *     - help document comments updated
 *
 * @endcond
 *
 */

#ifndef ACIM_FREQ_CTRL_H_
#define ACIM_FREQ_CTRL_H_
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/


#include "../MOTOR_LIB/motor_lib.h"

#if(UC_FAMILY == XMC4)
#include "../CPU_CTRL_XMC4/cpu_ctrl_xmc4.h"
#else
#include "../CPU_CTRL_XMC1/cpu_ctrl_xmc1.h"
#endif


#include "acim_freq_ctrl_conf.h"
#include <DAVE_common.h>

#if (ACIM_FREQ_CTRL_IS_ADC_AVAILABLE == 1U)
#include "../ADC_QUEUE/adc_queue.h"
#include <xmc_vadc.h>
#endif

#include "../PWM_SVM/pwm_svm.h"

#if (ACIM_FREQ_CTRL_IS_AUTOMATION_AVAILABLE == 1U)
#include "../AUTOMATION/automation.h"
#endif

#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 0U) && \
       (XMC_LIB_PATCH_VERSION >= 0U)))
#error "ACIM_FREQ_CTRL requires XMC Peripheral Library v2.0.0 or higher"
#endif

/**********************************************************************************************************************
* MACROS
**********************************************************************************************************************/
#define ACIM_FREQ_CTRL_ADCCAL_COUNT     (16U)        /**< Amplifier bias voltage calibration count*/
#define ACIM_FREQ_CTRL_MAX_OC_COUNTER   (100U)       /**< Maximum count used for over current detection*/
#define ACIM_FREQ_CTRL_VFSCALE          (10U)        /**< V/f constant scale*/
#define ACIM_FREQ_CTRL_AMPLITIDESCALE   (14U)
#define ACIM_FREQ_CTRL_POWER215         (32767U)     /**< 2^15*/
#define ACIM_FREQ_CTRL_Q15              (15U)        /**< unsigned integer 15*/
#define ACIM_FREQ_CTRL_LOWER_THRESHOLD_SPEED     (100U)       /**< Lower threshold speed, use for safe motor stop*/
#define ACIM_FREQ_CTRL_POTSCALE         (2U)        /**< Pot measurement scale*/
#define ACIM_FREQ_CTRL_TARGET_VALUE     (0x3FFFU)


/**********************************************************************************************************************
* ENUMS
**********************************************************************************************************************/
/**
 * @ingroup ACIM_FREQ_CTRL_enumerations
 * @{
 */
/**
 * This enumerates state of the App
 */
typedef enum ACIM_FREQ_CTRL_STATE
{
  ACIM_FREQ_CTRL_UNINITIALISED,    /**< default state after power on reset */
  ACIM_FREQ_CTRL_INITIALISED       /**< App state after INITIALIZED state*/

} ACIM_FREQ_CTRL_STATE_t;

/**
 * Status of the app which can be occured during initialization.
 */
typedef enum ACIM_FREQ_CTRL_STATUS
{
  ACIM_FREQ_CTRL_STATUS_SUCCESS,                    /*!< App status ok*/
  ACIM_FREQ_CTRL_STATUS_FAILURE,               /**< API execution failed */
  ACIM_FREQ_CTRL_STATUS_INVALID_PARAM,         /**< Input argument is not within the range */
  ACIM_FREQ_CTRL_STATUS_OPERATION_NOT_ALLOWED, /**< Operation is not allowed in the current state of the app */
  ACIM_FREQ_CTRL_STATUS_PERMISSION_DENIED      /**< Writr access is denied for the API */
} ACIM_FREQ_CTRL_STATUS_t;

/**
 * Enumerates the permission to update the parameter handler (PH)
 */
typedef enum ACIM_FREQ_CTRL_PH_WRITE_ACCESS
{
  ACIM_FREQ_CTRL_PH_WA_NOT_ALLOWED,     /**< Write operation not allowed */
  ACIM_FREQ_CTRL_PH_WA_ALLOWED          /**< Write operation is allowed under all the conditions */

} ACIM_FREQ_CTRL_PH_WA_t;
/**
 * Enumerates the parameter ID (PID)
 */
typedef enum ACIM_FREQ_CTRL_PARAMETER_ID
{
  ACIM_FREQ_CTRL_PID_CW_STATE       = 0U,   /**< control word */
  ACIM_FREQ_CTRL_PID_SPEED_REF      = 1U,   /**< speed reference*/
  ACIM_FREQ_CTRL_PID_VOLT_CONSTANT  = 2U,   /**< voltage constant */
  ACIM_FREQ_CTRL_PID_VOLT_OFFSET    = 3U,   /**< voltage offset */
  ACIM_FREQ_CTRL_PID_MOTOR_DIR      = 4U,   /**< motor direction */
  ACIM_FREQ_CTRL_PID_PWM_FREQUENCY  = 5U,   /**< pwm frequency */
  ACIM_FREQ_CTRL_PID_OC_LIMIT       = 6U,   /**< over current limit */
  ACIM_FREQ_CTRL_PID_VOLT_LIMIT     = 7U,   /**< voltage limit */
  ACIM_FREQ_CTRL_PID_POSITION_KP    = 8U,   /**< position control proportional gain */
  ACIM_FREQ_CTRL_PID_POSITION_KI    = 9U,   /**< position control integral gain */
  ACIM_FREQ_CTRL_PID_SLIP_KP        = 10U,  /**< slip control proportional gain */
  ACIM_FREQ_CTRL_PID_SLIP_KI        = 11U,  /**< slip control integral gain */
  ACIM_FREQ_CTRL_PID_POSITION_REF   = 12U,  /**< position reference */
  ACIM_FREQ_CTRL_PID_CURRENT_LIMIT  = 13U,  /**< current limit */
  ACIM_FREQ_CTRL_PID_CURRENT_KP     = 14U,  /**< current limit, proportional gain */
  ACIM_FREQ_CTRL_PID_CURRENT_KI     = 15U,  /**< current limit, integral gain */
  ACIM_FREQ_CTRL_PID_ANGLE_OFFSET   = 16U,  /**< angle offset */
  ACIM_FREQ_CTRL_PID_AMP_OFFSET     = 17U,  /**< amplitude offset */
  ACIM_FREQ_CTRL_PID_ADDITIVE_POS   = 18U,  /**< additive position */
  ACIM_FREQ_CTRL_PID_ADDITIVE_SPEED = 19U,  /**< additive speed */
  ACIM_FREQ_CTRL_PID_MAX            = 20U   /**< Number of parameters exposed by this app */

}ACIM_FREQ_CTRL_PID_t;
/**
 * This enumerates queue request availability
 */
typedef enum ACIM_FREQ_CTRL_QUEUE_ACTIVE
{
  ACIM_FREQ_CTRL_QUEUE_ACTIVE,                /*!<Queue request source is active*/
  ACIM_FREQ_CTRL_QUEUE_INACTIVE               /*!<Queue request source is not active*/

} ACIM_FREQ_CTRL_QUEUE_ACTIVE_t;
/**
 * This enumerates adc external trigger
 */
typedef enum ACIM_FREQ_CTRL_ADC_EXTTRIGGER
{
  ACIM_FREQ_CTRL_EXTERNALTRIGGER_ENABLED,  /**< External trigger enable */
  ACIM_FREQ_CTRL_EXTERNALTRIGGER_DISABLED  /**< External trigger is disabled */

} ACIM_FREQ_CTRL_ADC_EXTTRIGGER_t;

/**
 * This enumerates the run-time error id(EID) of the app(ACIM_FREQ_CTRL).
 */
typedef enum ACIM_FREQ_CTRL_ERROR_ID
{
  ACIM_FREQ_CTRL_EID_INIT_FAILED       = 0U,   /**<initialization failed*/
  ACIM_FREQ_CTRL_EID_SVP_REG_FAILED    = 1U,   /**<set value processing registration failed*/
  ACIM_FREQ_CTRL_EID_PCL_REG_FAILED    = 2U,   /**<primary control loop registration failed*/
  ACIM_FREQ_CTRL_EID_TRAP_ERROR        = 3U,   /**<trap detected*/
  ACIM_FREQ_CTRL_EID_OVERCURRENT       = 4U,   /**<over current detected*/
  ACIM_FREQ_CTRL_EID_MAX               = 5U   /**<Number of errors exposed by this app*/

}ACIM_FREQ_CTRL_EID_t;
/**
 * Enumerates the error severity level
 */
typedef enum ACIM_FREQ_CTRL_ERROR_SEVERITY
{
  ACIM_FREQ_CTRL_ERROR_INFO,             /**< Informative message */
  ACIM_FREQ_CTRL_ERROR_WARNING,          /**< Warning message */
  ACIM_FREQ_CTRL_ERROR,                  /**< Error in execution */
  ACIM_FREQ_CTRL_ERROR_CRITICAL          /**< Critical error */

}ACIM_FREQ_CTRL_ERROR_SEVERITY_t;

/**
 * Enumerates the status of the error id
 */
typedef enum ACIM_FREQ_CTRL_ERROR_STATUS
{
	ACIM_FREQ_CTRL_ERROR_CLEARED,     /**< Error is cleared */
	ACIM_FREQ_CTRL_ERROR_SET          /**< Error is set */

}ACIM_FREQ_CTRL_ERROR_STATUS_t;

/**
 * Enumerates the state of drive state machine(DSM)
 */
typedef enum ACIM_FREQ_CTRL_DRIVE_STATE_MACHINE
{
  ACIM_FREQ_CTRL_DSM_SWITCHED_OFF = 0U,
  ACIM_FREQ_CTRL_DSM_ENABLED,
  ACIM_FREQ_CTRL_DSM_SWITCHED_ON,
  ACIM_FREQ_CTRL_DSM_OPERATION,
  ACIM_FREQ_CTRL_DSM_COAST_STOP,
  ACIM_FREQ_CTRL_DSM_QUICK_STOP,
  ACIM_FREQ_CTRL_DSM_RAMP_DOWN,
  ACIM_FREQ_CTRL_DSM_ERROR,
  ACIM_FREQ_CTRL_DSM_SAFE_TORQUE_OFF,
  ACIM_FREQ_CTRL_DSM_RESERVE_9,
  ACIM_FREQ_CTRL_DSM_RESERVE_10,
  ACIM_FREQ_CTRL_DSM_USER_DEFINE_11,
  ACIM_FREQ_CTRL_DSM_USER_DEFINE_12,
  ACIM_FREQ_CTRL_DSM_RESERVE_13,
  ACIM_FREQ_CTRL_DSM_RESERVE_14,
  ACIM_FREQ_CTRL_DSM_TROUBLE

} ACIM_FREQ_CTRL_DSM_t;
typedef enum ACIM_FREQ_CTRL_CONTROL_WORD
{
  ACIM_FREQ_CTRL_CW_SWITCHED_OFF  = 0U,
  ACIM_FREQ_CTRL_CW_ENABLE       = 1U,
  ACIM_FREQ_CTRL_CW_SWITCH_ON    = 2U,
  ACIM_FREQ_CTRL_CW_OPERATE      = 3U,
  ACIM_FREQ_CTRL_CW_COAST_STOP   = 4U,
  ACIM_FREQ_CTRL_CW_QUICK_STOP   = 5U,
  ACIM_FREQ_CTRL_CW_RAMP_DOWN    = 6U,
  ACIM_FREQ_CTRL_CW_ERROR         = 7U,
  ACIM_FREQ_CTRL_CW_AUTOMATIC_ON  = 8U,
  ACIM_FREQ_CTRL_CW_ERROR_RESET   = 9U,
  ACIM_FREQ_CTRL_CW_RESUME_OPERATION   = 10U,
  ACIM_FREQ_CTRL_CW_RESUME_SWITCHED_ON = 11U,
  ACIM_FREQ_CTRL_CW_RESUME_ENABLED     = 12U
} ACIM_FREQ_CTRL_CW_t;
/**
 * Enumerates the state of motor control state machine(MSM)
 */
typedef enum ACIM_FREQ_CTRL_MOTOR_CONTROL_STATE_MACHINE
{
  ACIM_FREQ_CTRL_MSM_STOP = 0U,
  ACIM_FREQ_CTRL_MSM_INIT_INVERTER,
  ACIM_FREQ_CTRL_MSM_START_UP,
  ACIM_FREQ_CTRL_MSM_LOW_SPEED,
  ACIM_FREQ_CTRL_MSM_TRANSITION,
  ACIM_FREQ_CTRL_MSM_NORMAL_OPERATION,
  ACIM_FREQ_CTRL_MSM_RESERVE_1,
  ACIM_FREQ_CTRL_MSM_RESERVE_2,
  ACIM_FREQ_CTRL_MSM_RESERVE_3,
  ACIM_FREQ_CTRL_MSM_BOOTSTRAP,
  ACIM_FREQ_CTRL_MSM_USER_DEFINE_2,
  ACIM_FREQ_CTRL_MSM_USER_DEFINE_3,
  ACIM_FREQ_CTRL_MSM_USER_DEFINE_4,
  ACIM_FREQ_CTRL_MSM_USER_DEFINE_5,
  ACIM_FREQ_CTRL_MSM_RESERVE_4,
  ACIM_FREQ_CTRL_MSM_ERROR

} ACIM_FREQ_CTRL_MSM_t;



/**
 * Enumerates the state of task scheduler(TS)
 */
typedef enum ACIM_FREQ_CTRL_TASK_SCHEDULER
{
  ACIM_FREQ_CTRL_TS_DISABLED,           /**< disabled */
  ACIM_FREQ_CTRL_TS_SW_DIV,             /**< 1/software divider, Priority is same as fast control loop ISR */
  ACIM_FREQ_CTRL_TS_PCL_ISR,            /**< primary control loop(PCL) ISR, Can configure priority*/
  ACIM_FREQ_CTRL_TS_USER_CALL,          /**< API call, user has to call control loops*/
  ACIM_FREQ_CTRL_TS_AUTOMATION,         /**< automation */
  ACIM_FREQ_CTRL_TS_PCL_TASK            /**< svp control is same as pcl control */

}ACIM_FREQ_CTRL_TS_t;

/**
 * Enumerates function block(ACIM_FREQ_CTRL) input parameter number
 */
typedef enum ACIM_FREQ_CTRL_FB_IN_PARAM
{
  ACIM_FREQ_CTRL_FB_IN_SPEED_REF            /**< Speed reference */
  
}ACIM_FREQ_CTRL_FB_IN_PARAM_t;

/**
 * Enumerates function block(ACIM_FREQ_CTRL) output parameter number
 */
typedef enum ACIM_FREQ_CTRL_FB_OUT_PARAM
{
  ACIM_FREQ_CTRL_FB_OUT_USER_SPEED,      /**< User speed reference.This is input to the RAMP FB. */
  ACIM_FREQ_CTRL_FB_OUT_SPEED_SCALE,     /**< Speed scale.This is input to the RAMP FB. */
  ACIM_FREQ_CTRL_FB_OUT_ANGLE,           /**< angle */
  ACIM_FREQ_CTRL_FB_OUT_AMPLITUDE        /**< amplitude */
}ACIM_FREQ_CTRL_FB_OUT_PARAM_t;

/**
 * This enumerates bootstrap status
 */
typedef enum ACIM_FREQ_CTRL_BOOTSTRAP_STATUS
{
	ACIM_FREQ_CTRL_BOOTSTRAP_ACTIVE,     /**< Boot Strap is active */
	ACIM_FREQ_CTRL_BOOTSTRAP_COMPLETED   /**< Boot Strap is completed */

} ACIM_FREQ_CTRL_BOOTSTRAP_STATUS_t;

/**
 * This enumerates the motor direction
 */
typedef enum ACIM_FREQ_CTRL_MOTOR_DIRECTION
{

  ACIM_FREQ_CTRL_ANTICLOCKWISE_DIR  = -1,    /**< reverse direction */
  ACIM_FREQ_CTRL_CLOCKWISE_DIR      =  1     /**<forward direction */

}ACIM_FREQ_CTRL_MD_t;

/**
 * @}
 */
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
/**
 * @ingroup ACIM_FREQ_CTRL_datastructures
 * @{
 */

/**
 * Function pointer to point set parameter API.
 */
typedef void (*ACIM_FREQ_CTRL_SETPARAMVALUE_PTR)(void *handle_ptr,uint32_t value);
/**
 * Function pointer to point task registration call back function.
 */
typedef void (*ACIM_FREQ_CTRL_TASKREGISTER_PTR_t)(void* handle_ptr);
/**
 * Function pointer to point error handler call back function.
 */
typedef void (*ACIM_FREQ_CTRL_ERRORHANDLER_PTR_t)(void *handle_ptr);

/**
 * This structure hold the configuration of each parameters.
 */
typedef struct ACIM_FREQ_CTRL_PARAMETER_TABLE_ENTRY
{
  int32_t    *param_value;                              /**< parameter pointer */
  int32_t     minval;                                   /**< Minimum limit of the parameter */
  int32_t     maxval;                                   /**< Maximum limit of the parameter */
  uint32_t    scale;                                    /**< Scale factor, pre-calculated value*/
  uint32_t    inv_scale;                                /**< Inverse scale factor, pre-calculated value */
  ACIM_FREQ_CTRL_SETPARAMVALUE_PTR set_paramvalue_ptr;  /**< Function pointer for set parameter value */
  uint8_t     write_access;                             /**< protect the parameter value at run time*/
  uint8_t     size;                                     /**< future use */
} ACIM_FREQ_CTRL_PT_ENTRY_t;

/**
 * This structure hold error information of each error.
 */
typedef struct ACIM_FREQ_CTRL_ERROR_TABLE_ENTRY
{
  ACIM_FREQ_CTRL_ERRORHANDLER_PTR_t  error_handler_ptr_t;  /**< Callback functions to be called when error status is updated */
  uint8_t                        error_id;             /**< Error ID */
  uint8_t                        error_status;         /**< Error Status */
  uint8_t                        error_severity;       /**< Severity of the error */

}ACIM_FREQ_CTRL_ET_ENTRY_t;

/**
 * This structure hold all the parameters of position control block.
 */
typedef struct ACIM_FREQ_CTRL_Position_Control
{
  MOTOR_LIB_PIHandle_t*const pi_ptr;     /*!< Pointer to PI handle*/
  int32_t   position_set;                /*!< Configured reference input for position control block.*/
  int32_t*  input_ptr;                   /*!< Input pointer, pointing to the actual position input.*/
  int32_t   output;                      /*!< Output of position control block.*/
  int32_t   additive_position;           /*!< Configured additive position value.*/
  int32_t   actual_position;             /*!< Actual position input.*/
} ACIM_FREQ_CTRL_PC_t;

/**
 * This structure hold all the parameters of slip control block.
 */
typedef struct ACIM_FREQ_CTRL_Slip_Control
{
  MOTOR_LIB_PIHandle_t*const pi_ptr;  /*!< Pointer to PI handle*/
  int32_t  speed_set;               /*!< Reference input*/
  int32_t* input_ptr;                /*!< Input pointer, pointing to the actual speed input.*/
  int32_t  output;                   /*!< Output of slip control block.*/
  int32_t  additive_speed;           /*!< Configured additive speed value.*/

} ACIM_FREQ_CTRL_SC_t;

/**
 * This structure hold all the parameters of current limit block.
 */
typedef struct ACIM_FREQ_CTRL_Current_Limit
{
  MOTOR_LIB_PIHandle_t*const pi_ptr;    /*!< Pointer to PI handle*/
  int32_t  current_limit;              /*!< Reference input for current limit.*/
  int32_t* input_ptr;                   /*!< Input pointer, pointing to the actual current input*/
  int32_t  output;                      /*!< Output of current limit block.*/
} ACIM_FREQ_CTRL_CL_t;

/**
 * This structure hold all the parameters of v/f control block.
 */
typedef struct ACIM_FREQ_CTRL_Vf_Control
{
  uint32_t vf_constant;                 /*!< Configured V/f constant*/
  uint32_t vf_offset;                   /*!< Configured V/f offset*/
  int32_t  input;                       /*!< This is the speed reference value. Input to the V/f control.*/
  int32_t  output_angle;                /*!< Output angle, V/f control Output.*/
  uint32_t output_amplitude;            /*!< Output amplitude, V/f control Output.*/

} ACIM_FREQ_CTRL_VF_t;


#if (ACIM_FREQ_CTRL_IS_ADC_AVAILABLE == 1U)
/**
 * This structure hold all the parameters related to adc configuration.
 */
typedef struct ACIM_FREQ_CTRL_ADCConfig
{
  ADC_QUEUE_ENTRY_t            *const queue_entry_hdlarray[4][4];             /*!< Pointer to queue entry structure*/
  ADC_QUEUE_t                  *const qapp_handlearray[4];                    /*!< Pointer to queue app handler*/
  XMC_VADC_RESULT_CONFIG_t     *const vadc_reshandle_array[4];                /*!< Pointer to result configuration structure*/
  XMC_VADC_CHANNEL_CONFIG_t    *const vadc_chhandle_array[4];                 /*!< Pointer to channel configuration structure*/
  XMC_VADC_GROUP_t             *const vadc_group_pointerarray[4];             /*!< Pointer to group pointer structure*/
  uint8_t                      queue_active[4];                              /*!< Queue configuration*/
  uint8_t                      channel_num_array[4];                         /*!< Channel number configuration*/
  uint8_t                      result_num_array[4];                          /*!< Result register number configuration*/
} ACIM_FREQ_CTRL_ADCConfig_t;
#endif
/**
 * This structure holds the ISR configuration parameters.
 */
typedef struct ACIM_FREQ_CTRL_ISRHandle
{
  uint8_t node_id;      /*!< interrupt node id*/
  uint8_t priority;     /*!< interrupt priority*/
  uint8_t sub_priority; /*!< interrupt sub priority*/

}ACIM_FREQ_CTRL_ISRHandle_t;

/**
 * This structure holds the configurable parameters of this app.
 * These parameters don't change at run time.
 */
typedef struct ACIM_FREQ_CTRL_Config
{
  uint32_t        nominal_speed;               /*!< Configured no load speed(rpm)*/
  uint32_t        voltage_adc_scale;
  uint16_t        dclink_voltage;              /*!< Configured dc link voltage */
  uint16_t        current_amplifier_offset;    /*!< Configured Current Amplifier Offset Value */
  uint16_t        bootstrap_time;              /*!< Configured boot strap time(ns) */
  uint16_t        specified_volt;              /*!< Configured voltage, used for voltage compensation */
  uint8_t         pole_pair;                   /*!< Configured number of pole pair*/
  uint8_t         pcl_task_conf;               /*!< Configured state of PCL task scheduler*/
  uint8_t         svp_task_conf;               /*!< Configured state of SVP task scheduler*/
  uint8_t         dsm_task_conf;               /*!< Configured state of DSM task scheduler*/
  uint8_t         fcl_divider;                 /*!< FCL divider value*/
  uint8_t         pcl_divider;                 /*!< PCL divider value*/
  uint8_t         svp_divider;                 /*!< SVP divider value*/
  /**
   * For all the variable (prefix with enable) is enabled if value is 1.
   * 0 - Disabled
   * 1 - Enabled
   */
  uint32_t  enable_automation           :1;     /*!< Enable/Disable automation */
  uint32_t  enable_position_control     :1;     /*!< Enable/Disable position control block */
  uint32_t  enable_slip_control         :1;     /*!< Enable/Disable slip control block */
  uint32_t  enable_current_limit        :1;     /*!< Enable/Disable current limit block */
  uint32_t  enable_biasvoltage          :1;     /*!< Enable/Disable Amplifier Bias Voltage Calibration */
  uint32_t  enable_over_current         :1;     /*!< Enable/Disable Over current detection*/
  uint32_t  enable_avg_current          :1;     /*!< Enable/Disable Average current measurement */
  uint32_t  enable_voltage_compensation :1;     /*!< Enable/Disable Voltage Compensation */
  uint32_t  enable_pot_measurement      :1;     /*!< Enable/Disable, Speed measurement via pot. */
  uint32_t  enable_error_callback       :1;     /*!< Enable/Disable, User define error handler function call. */
  uint32_t  enable_iavg_actcurrent      :1;     /*!< I average is selected as actual current */
} ACIM_FREQ_CTRL_Config_t;

/**
 * This structure holds the run time parameters, pointer to consumed app handle and
 * sub structures associated with this app.
 */
typedef struct ACIM_FREQ_CTRL_Handle
{
  const ACIM_FREQ_CTRL_Config_t       *const acim_config_ptr;        /*!< Pointer to ACIM_FREQ_CTRL config structure */
  PWM_SVM_t                           *const pwm_svm_ptr;            /*!< Pointer to PWM_SVM App handle */
  ACIM_FREQ_CTRL_VF_t                 *const vf_control_ptr;         /*!< Pointer to V(f) control module */
  ACIM_FREQ_CTRL_PC_t                 *const position_control_ptr;   /*!< Pointer to position control module */
  ACIM_FREQ_CTRL_SC_t                 *const slip_control_ptr;       /*!< Pointer to slip control module */
  ACIM_FREQ_CTRL_CL_t                 *const current_limit_ptr;      /*!< Pointer to current limit module */
  ACIM_FREQ_CTRL_PT_ENTRY_t           *const param_table_ptr;        /*!< Pointer to parameter table  */
  ACIM_FREQ_CTRL_ET_ENTRY_t           *const error_table_ptr;        /*!< Pointer to error table */
  ACIM_FREQ_CTRL_ISRHandle_t          *const fcl_config_ptr;         /*!< Pointer to Fast control loop(FCL) ISR handler */
  ACIM_FREQ_CTRL_ISRHandle_t          *const pcl_config_ptr;         /*!< Pointer to Primary control loop(PCL) ISR handler */
  MOTOR_LIB_FeedForwardHandle_t       *const feed_forward_ptr;       /*!< Pointer to position feed forward module. */
  MOTOR_LIB_PT1Handle_t               *const voltcomp_filter_ptr;    /*!< Pointer to PT1 filter structure. Used for voltage compensation. */

  #if (ACIM_FREQ_CTRL_IS_ADC_AVAILABLE == 1U)
  ACIM_FREQ_CTRL_ADCConfig_t          *const adc_config_ptr;         /*!< Pointer to ADC configuration structure. */
  #endif
  #if (ACIM_FREQ_CTRL_IS_AUTOMATION_AVAILABLE == 1U)
  AUTOMATION_FB_HANDLE_t              *const ramp_fb_ptr;            /*!< Pointing to FB(ACIM_FREQ_CTRL) output structure. */
  AUTOMATION_t                        *const automation_ptr;         /*!< Pointer to automation app handle. */
  AUTOMATION_FB_HANDLE_t              *const acim_freq_ctrl_fb_ptr;      /*!< Pointing to FB(ACIM_FREQ_CTRL) input structure. */
  AUTOMATION_SM_t                     *const acim_statemachine;
  #endif
  ACIM_FREQ_CTRL_TASKREGISTER_PTR_t   pcl_function_ptr;              /*!< PCL task registration, call back function pointer.*/
  ACIM_FREQ_CTRL_TASKREGISTER_PTR_t   svp_function_ptr;              /*!< SVP task registration, call back function pointer. */
  ACIM_FREQ_CTRL_TASKREGISTER_PTR_t   dsm_function_ptr;              /*!< DSM task registration, call back function pointer. */

  ACIM_FREQ_CTRL_CW_t                 cw_state;                      /*!< Hold the the control word state. */
  ACIM_FREQ_CTRL_MSM_t                msm_state;                     /*!< Hold the the motor control state machine state.*/

  uint32_t                        pwm_frequency;                 /*!< PWM frequency. */
  uint32_t                        operational_error;             /*!< Each bit of this variable represent particular run time error status.
                                                                      Error position is identified by error id. */
  uint32_t                        angle_offset;                  /*!< Configured angle offset. Can be changed in run time.*/
  uint32_t                        amplitude_offset;              /*!< Configured amplitude offset. Can be changed in run time.*/
  uint32_t                        voltage_limit;                 /*!< Configured maximum voltage limit */
  uint32_t                        overcurrent_limit;             /*!< This is the maximum time counter for over current detection*/
  int32_t                         user_speed_set;                /*!< Configured motor speed set.If position control is disable.*/
  int32_t                         user_position_set;             /*!< Configured motor position set*/
  int32_t                         *speed_set_ptr;                /*!< Pointer to the user speed set.*/
  int32_t                         *position_set_ptr;             /*!< Pointer to the user position set.*/
  uint32_t                        amplitude;                     /*!< Run time variable for amplitude. This is input to the modulator. */
  uint32_t                        angle;                         /*!< Run time variable for angle. This is input to the modulator. */
  uint32_t                        overcurrent_counter;           /*!< Hold the counter value for over current check.*/
  uint32_t                        angle_scale;                   /*!< Angle-Speed scale. */
  uint32_t                        pcl_time;                      /*!< Configured pcl time. */
  uint32_t                        svp_time;                      /*!< Configured svp time. */
  uint32_t                        dsm_time;                      /*!< Configured dsm time. */
  uint32_t                        msm_time;                      /*!< Configured motor control state machine (msm) time in micro second. */
  int32_t                         motor_current;                /*!< Hold actual motor current. */
  int16_t                         dclink_voltage;                /*!< Hold actual dc link voltage. */
  uint16_t                        bootstrap_count;              /*!< Configured boot strap count */
  uint16_t                        bootstrap_index;
  uint16_t                        ampoffset;
  int8_t                          motor_direction;               /*!< Configured motor direction.*/
  uint8_t                         app_id;						 /*!< unique app Id. */
  uint8_t                         fcl_div_value;                 /*!< Run time variable for FCL task divider value. */
  uint8_t                         pcl_div_value;                 /*!< Run time variable for PCL task divider value. */
  uint8_t                         svp_div_value;                 /*!< Run time variable for SVP task divider value. */
  uint8_t                         registered_task_svp;           /*!< 1: SVP task is registered in automation APP. \n 0: SVP task is not registered  */
  uint8_t                         registered_task_pcl;           /*!< 1: PCL task is registered in automation APP. \n 0: PCL task is not registered  */
  uint8_t                         state;                         /*!< This is the App state.*/

} ACIM_FREQ_CTRL_t;

/**
 * @}
 */
#ifdef __cplusplus
extern "C" {
#endif
/**
 * @ingroup ACIM_FREQ_CTRL_apidoc
 * @{
 */
/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/**
 * @brief Returns the ACIM_FREQ_CTRL APP version information.
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 * <BR>
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 * <BR>
 * \par<b>Example Usage: </b><br>
 * <BR>
 * @code
 * #include <DAVE.h>
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   DAVE_APP_VERSION_t version;
 *
 *   status = DAVE_Init();	// ACIM_FREQ_CTRL_Init() is called from DAVE_Init()
 *
 *   version = ACIM_FREQ_CTRL_GetAppVersion();
 *   // More code here
 *   while(1)
 *   {
 *
 *   }
 *  return 0;
 * }
 * @endcode
 */
DAVE_APP_VERSION_t ACIM_FREQ_CTRL_GetAppVersion(void);
/**
* @brief Iinitializes ACIM_FREQ_CTRL APP and its dependent APP's.
* @param HandlePtr pointer to an object of ACIM_FREQ_CTRL module
* @return ACIM_FREQ_CTRL_STATUS_t status of operation \n
* <BR>
*
* \par<b>Description: </b><br>
* Initializes dependent APPs - PWM_SVM, AUTOMATION (conditional) and ADC_QUEUE (conditional
* and enables consumed NVIC nodes.This is called by DAVE_Init.
* This is the first API which application must invoke to use ACIM_FREQ_CTRL APP.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
* @code
* #include <DAVE.h>
*
* int main(void)
* {
*   DAVE_STATUS_t init_status;
*
*   // Initialize ACIM_FREQ_CTRL APP
*   // ACIM_FREQ_CTRL_Init() is called within DAVE_Init().
*   init_status = DAVE_Init();
*
*   // More code here
*   while(1)
*   {
*
*   }
*   return (1);
* }
* @endcode<BR>
*/
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_Init(ACIM_FREQ_CTRL_t* const HandlePtr);
/**
* @brief Starts the motor with configured parameters.
* It register PCL and SVP task in automation framework if enabled.
* @param HandlePtr pointer to an object of ACIM_FREQ_CTRL module
* @return void
* <BR>
*
* \par<b>Description: </b><br>
* This API need to be invoked to start the motor.
* This starts the control loop execution.
* It changes the state of motor state machine(MSM) to ACIM_FREQ_CTRL_MSM_INIT_INVERTER.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
* @code
  #include <DAVE.h>
  int main (void)
  {
    DAVE_STATUS_t init_status;
    init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
    ACIM_FREQ_CTRL_MotorStart(&ACIM_FREQ_CTRL_0);
    while(1);
    return 0;
  }
* @endcode
*/
void ACIM_FREQ_CTRL_MotorStart(ACIM_FREQ_CTRL_t * const HandlePtr);
/**
* @brief Stops the motor.
* @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
* @return <b>void</b><BR>
*
* \par<b>Description: </b><br>
* This API need to be invoked to stop the motor.
* It stops pwm_svm,disable inverter, de-register PCL and SVP task.
* It changes the state of motor state machine(MSM) to ACIM_FREQ_CTRL_MSM_STOP.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
* @code
  #include <DAVE.h>
  int main (void)
  {
    DAVE_STATUS_t init_status;
    init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
    ACIM_FREQ_CTRL_MotorStart(&ACIM_FREQ_CTRL_0);
    //delay
    ACIM_FREQ_CTRL_MotorStop(&ACIM_FREQ_CTRL_0);
    while(1);
    return 0;
  }
* @endcode
*/
void ACIM_FREQ_CTRL_MotorStop(ACIM_FREQ_CTRL_t * const HandlePtr);
/**
 * @brief Calculates the voltage amplitude for SVM.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Calculates amplitude for SVM algorithm.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_MotorStart(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * This is the Fast control loop ISR.
 * void ACIM_FREQ_CTRL_FastControlLoop_ISR()
 * {
 *  //Before updating ACIM_FREQ_CTRL_Amplitude_Calculation function make sure "input"
 *  // of structure vf_control_ptr is updated.
 *   ACIM_FREQ_CTRL_Amplitude_Calculation(&ACIM_FREQ_CTRL_0);
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_Amplitude_Calculation(ACIM_FREQ_CTRL_t* const HandlePtr);
/**
 * @brief Calculates the angle for SVM.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Calculates angle for SVM algorithm.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_MotorStart(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * This is the Fast control loop ISR.
 * void ACIM_FREQ_CTRL_FastControlLoop_ISR()
 * {
 *  //Before updating ACIM_FREQ_CTRL_AngleRamp function make sure "input"
 *  // of structure ACIM_FREQ_CTRL_Vf_Control is updated
 *  //angle calculation
 *    ACIM_FREQ_CTRL_AngleRamp(&ACIM_FREQ_CTRL_0);
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_AngleRamp(ACIM_FREQ_CTRL_t* const HandlePtr);
/**
 * @brief To sense and limit the actual current value.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return void
 * <BR>
 * \par<b>Description: </b><br>
 * This function compare the the actual current and current limit value.
 * If actual current limit exceed the configured limit then decrease the output value.
 * Called from fast control loop ISR.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_MotorStart(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * This is the Fast control loop ISR.
 * void ACIM_FREQ_CTRL_FastControlLoop_ISR()
 * {
 *   ACIM_FREQ_CTRL_CurrentLimit(&ACIM_FREQ_CTRL_0);
 * }
 *
 * @endcode
 */
void ACIM_FREQ_CTRL_CurrentLimit(ACIM_FREQ_CTRL_t* const HandlePtr);
/**
 * @brief This is the position control module of ACIM_FREQ_CTRL APP.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Position control module of ACIM_FREQ_CTRL APP.Internally this module calls PI controller loop and drive the motor to reach set position.
 * This function called from primary control loop.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_MotorStart(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * This is the primary control loop ISR.
 * void _PrimaryControlLoop_ISR()
 * {
 *   ACIM_FREQ_CTRL_PositionControl(&ACIM_FREQ_CTRL_0);
 * }
 *
 * @endcode
 */
void ACIM_FREQ_CTRL_PositionControl(ACIM_FREQ_CTRL_t* const HandlePtr);
/**
 * @brief This is the slip control module of ACIM_FREQ_CTRL APP.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * It will do slip control with the help of PI controller.It expects slip input.
 * This function called from primary control loop.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_MotorStart(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * This is the primary control loop ISR.
 * void _PrimaryControlLoop_ISR()
 * {
 *   ACIM_FREQ_CTRL_SlipControl(&ACIM_FREQ_CTRL_0);
 * }
 *
 * @endcode
 */
void ACIM_FREQ_CTRL_SlipControl(ACIM_FREQ_CTRL_t* const HandlePtr);
/**
 * @brief Executes the motor control state machine (MSM) of ACIM_FREQ_CTRL APP.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * This function executes the motor control state machine (MSM) of ACIM_FREQ_CTRL APP.
 * This state machine is part of drive state machine(operation 3).
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_MotorStart(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * This is the primary control loop ISR.
 * void _PrimaryControlLoop_ISR()
 * {
 *   ACIM_FREQ_CTRL_DSM(&ACIM_FREQ_CTRL_0);
 * }
 *
 * void ACIM_FREQ_CTRL_DSM(ACIM_FREQ_CTRL_t*const HandlePtr)
 * {
 *  switch(condition)
 *  {
 *   case 3:
 *   ACIM_FREQ_CTRL_MSM(HandlePtr);
 *   break;
 *  }
 * }
 *
 * @endcode
 *
 */
void ACIM_FREQ_CTRL_MSM(ACIM_FREQ_CTRL_t* const HandlePtr);
/**
 * @brief Configure the motor speed.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param speed input speed of type int32_t
 * @return ACIM_FREQ_CTRL_STATUS_t
 * <BR>
 *
 * \par<b>Description: </b><br>
 * This API configures the motor speed.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint32_t speed = 100;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_SetSpeed(&ACIM_FREQ_CTRL_0, speed);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetSpeed(ACIM_FREQ_CTRL_t*const HandlePtr, int32_t speed);
/**
 * @brief Returns the motor speed.
 * @param HandlePtr  Constant pointer to ACIM_FREQ_CTRL APP Handle.
 * @return int32_t Returns motor speed
 * <BR>
 * \par<b>Description: </b><br>
 * Returns the motor speed.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   int32_t speed;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   speed = ACIM_FREQ_CTRL_GetSpeed(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
int32_t ACIM_FREQ_CTRL_GetSpeed(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Start PWM timers synchronously.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return void
 * <BR>
 * \par<b>Description: </b><br>
 * This API start PWM timers synchronously for configured PWM slices.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_StartPWMTimer(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_StartPWMTimer(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Stop the PWM timers.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return void
 * <BR>
 * \par<b>Description: </b><br>
 * This API stops the PWM timers.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_StopPWMTimer(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_StopPWMTimer(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Set the voltage constant of v/f control.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param value voltage constant of type uint32_t
 * @return ACIM_FREQ_CTRL_STATUS_t
 * <BR>
 * \par<b>Description: </b><br>
 * Configures voltage constant of v/f control algorithm.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t vf_constant = 100;
 *   DAVE_STATUS_t init_status;
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetVoltageConstant(&ACIM_FREQ_CTRL_0, vf_constant);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetVoltageConstant(ACIM_FREQ_CTRL_t*const HandlePtr, uint32_t value);
/**
 * @brief Returns the voltage constant of v/f control.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t V/f voltage constant
 * <BR>
 * \par<b>Description: </b><br>
 * Returns configured voltage constant of v/f control.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t vf_constant;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   vf_constant = ACIM_FREQ_CTRL_GetVoltageConstant(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetVoltageConstant(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Set the voltage offset of v/f control.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param value uint32_t voltage offset to be set
 * @return ACIM_FREQ_CTRL_STATUS_t
 * <BR>
 * \par<b>Description: </b><br>
 * Configures voltage offset of v/f control.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t vf_offset = 100;
 *   DAVE_STATUS_t init_status;
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetVoltageOffset(&ACIM_FREQ_CTRL_0, vf_offset);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetVoltageOffset(ACIM_FREQ_CTRL_t*const HandlePtr, uint32_t value);

/**
 * @brief Return the voltage offset of v/f control.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle
 * @return uint32_t
 * <BR>
 * \par<b>Description: </b><br>
 * Returns the configured voltage offset of v/f control.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t voltage_offset;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   voltage_offset = ACIM_FREQ_CTRL_GetVoltageOffset(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetVoltageOffset(ACIM_FREQ_CTRL_t*const HandlePtr);

/**
 * @brief Set the motor direction.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param value Motor direction of type ACIM_FREQ_CTRL_MD_t *
 * @return ACIM_FREQ_CTRL_STATUS_t
 * <BR>
 * \par<b>Description: </b><br>
 * Configures motor direction.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   ACIM_FREQ_CTRL_MD_t direction = ACIM_FREQ_CTRL_CLOCKWISE_DIR;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetMotorDirection(&ACIM_FREQ_CTRL_0, direction);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetMotorDirection(ACIM_FREQ_CTRL_t*const HandlePtr, ACIM_FREQ_CTRL_MD_t value);
/**
 * @brief Returns the motor direction.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return int32_t Motor direction
 * <BR>
 * \par<b>Description: </b><br>
 * Returns the motor direction.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   int32_t direction;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   direction = ACIM_FREQ_CTRL_GetMotorDirection(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
int32_t ACIM_FREQ_CTRL_GetMotorDirection(ACIM_FREQ_CTRL_t*const HandlePtr);

/**
 * @brief Set the control word. Its user command to control the drive state machine.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param value uint32_t control word state to be set
 * @return ACIM_FREQ_CTRL_STATUS_t
 * <BR>
 * \par<b>Description: </b><br>
 * This API set the control word. Its user command to control the drive state machine.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   ACIM_FREQ_CTRL_CW_t cw_state = ACIM_FREQ_CTRL_CW_INIT;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_SetControlWordState(&ACIM_FREQ_CTRL_0, (uint32_t)cw_state);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetControlWordState(ACIM_FREQ_CTRL_t*const HandlePtr, uint32_t value);

/**
 * @brief Returns the control word current state.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t Current control word state
 * <BR>
 * \par<b>Description: </b><br>
 * Returns the control word current state.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t cw_state;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   cw_state = ACIM_FREQ_CTRL_GetControlWordState(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetControlWordState(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief It scans the error status and report the error to error handler of automation framework.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * This API scan the error status and report the error to error handler
 * of automation framework.Also call the user define error function if enabled in the GUI.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_ReportError(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */

void ACIM_FREQ_CTRL_ReportError(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Scans the error status and clears the errors.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return void
 * <BR>
 * \par<b>Description: </b><br>
 * This API scan the error status and clear the errors.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_clearErrorState(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_ClearErrorState(ACIM_FREQ_CTRL_t*const HandlePtr);

/**
 * @brief Returns boot strap status.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return ACIM_FREQ_CTRL_BOOTSTRAP_STATUS_t
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Return ACIM_FREQ_CTRL_BOOTSTRAP_COMPLETED after completion of boot strap.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   ACIM_FREQ_CTRL_BOOTSTRAP_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_BootStrap(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_BOOTSTRAP_STATUS_t ACIM_FREQ_CTRL_BootStrap(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Reads and returns the motor current.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint16_t Measured current value
 * <BR>
 * \par<b>Description: </b><br>
 * This function reads and returns the motor current with the help of ADC.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint16_t current_value;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   current_value = ACIM_FREQ_CTRL_GetCurrentValue(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint16_t ACIM_FREQ_CTRL_GetCurrentValue(ACIM_FREQ_CTRL_t*const HandlePtr);

/*
 * @brief Detects motor over current and stops if exceeds.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * If over current detection is enabled then motor will be stopped if current is
 * greater than the max over current limit.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_OverCurrentDetection(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_OverCurrentDetection(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Reads the potentiometer value and control the motor speed.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return void
 * <BR>
 * \par<b>Description: </b><br>
 * If position control is disable then motor speed reference is controlled based on potentiometer value.
 * To use potentiometer, configure pot in the measurements tab(GUI) and assign the correct pin.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_PotMeasurement(&ACIM_FREQ_CTRL_0);
 *
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_PotMeasurement(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Compensate DC link voltage variations by adjusting the duty cycle.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Reads the DC link voltage through ADC.It compensates duty cycle for the DC link voltage error based on this value.
 * To use voltage compensation configure DC link voltage in the measurements tab(GUI) and assign the correct pin.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_VoltageCompensation(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_VoltageCompensation(ACIM_FREQ_CTRL_t*const HandlePtr);

/**
 * @brief Configures over current limit value.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param over_current_val Over current limit
 * @return ACIM_FREQ_CTRL_STATUS_t Returns success if over current limit is in valid range
 * <BR>
 * \par<b>Description: </b><br>
 * Configures over current limit value for current control.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint16_t over_current_val = 100;
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetOverCurrentLimit(&ACIM_FREQ_CTRL_0, over_current_val);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetOverCurrentLimit(ACIM_FREQ_CTRL_t*const HandlePtr,uint32_t over_current_val);

/**
 * @brief Return over current limit.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t Returns configured over current limit
 * <BR>
 * \par<b>Description: </b><br>
 * This function return configured over current limit.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t current_value;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   current_value = ACIM_FREQ_CTRL_GetOverCurrentLimit(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetOverCurrentLimit(ACIM_FREQ_CTRL_t*const HandlePtr);

/**
 * @brief Configures maximum amplitude limit.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param voltlimitval voltage limit of type uint32_t
 * @return ACIM_FREQ_CTRL_STATUS_t Returns success if \a voltlimitval is in valid range
 * <BR>
 * \par<b>Description: </b><br>
 * Configures maximum amplitude limit.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint16_t voltlimitval = 80;
 *   DAVE_STATUS_t init_status;
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetVoltLimit(&ACIM_FREQ_CTRL_0, voltlimitval);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetVoltLimit(ACIM_FREQ_CTRL_t*const HandlePtr,uint32_t voltlimitval);
/**
 * @brief Returns the maximum voltage limit in term of percentage to the maximum amplitude.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t Returns configured voltage limit
 * <BR>
 * \par<b>Description: </b><br>
 * Returns the maximum voltage limit in term of percentage to the maximum amplitude.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint32_t voltage_limit;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   voltage_limit = ACIM_FREQ_CTRL_GetVoltLimit(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetVoltLimit(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Set proportional gain for position control.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param kp Position control PI proportional gain
 * @return ACIM_FREQ_CTRL_STATUS_t Returns success if \a kp is in valid range
 * <BR>
 * \par<b>Description: </b><br>
 * Configures proportional gain for position control.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t kp = 100;
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetPositionProportionalGain(&ACIM_FREQ_CTRL_0, kp);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetPositionProportionalGain(ACIM_FREQ_CTRL_t*const HandlePtr,uint32_t kp);
/**
 * @brief Returns configured proportional gain used for position PI control.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t Position PI control control proportional gain.
 * <BR>
 * \par<b>Description: </b><br>
 * Returns configured proportional gain used for position PI control.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t current_value;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   current_value = ACIM_FREQ_CTRL_GetPositionProportionalGain(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetPositionProportionalGain(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Configures integral gain for position PI control.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param ki Integral gain of type uint32_t
 * @return ACIM_FREQ_CTRL_STATUS_t Returns success if \a ki is in valid range
 * <BR>
 * \par<b>Description: </b><br>
 * Configures integral gain for position PI control.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t ki = 100;
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetPositionProportionalGain(&ACIM_FREQ_CTRL_0, ki);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetPositionIntegralGain(ACIM_FREQ_CTRL_t*const HandlePtr,uint32_t ki);
/**
 * @brief Returns configured integral gain used for position control.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t Configured integral gain used for position control.
 * <BR>
 * \par<b>Description: </b><br>
 * Returns configured integral gain used for position control.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t current_value;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   current_value = ACIM_FREQ_CTRL_GetPositionIntegralGain(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetPositionIntegralGain(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Set proportional gain for slip control.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param kp uint16_t input value
 * @return ACIM_FREQ_CTRL_STATUS_t Returns success if \a kp is in valid range
 * <BR>
 * \par<b>Description: </b><br>
 * This function set proportional gain for slip control.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t kp = 100;
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetSlipProportionalGain(&ACIM_FREQ_CTRL_0, kp);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetSlipProportionalGain(ACIM_FREQ_CTRL_t*const HandlePtr,uint32_t kp);
/**
 * @brief Returns configured proportional gain used for slip control.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t Configured proportional gain used for slip control.
 * <BR>
 * \par<b>Description: </b><br>
 * Returns configured proportional gain used for slip control.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t kp_slip;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   kp_slip = ACIM_FREQ_CTRL_GetSlipProportionalGain(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetSlipProportionalGain(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Configures integral gain for slip control.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param ki uint32_t Integral gain for slip control
 * @return ACIM_FREQ_CTRL_STATUS_t Returns success if \a ki is in valid range
 * <BR>
 * \par<b>Description: </b><br>
 * Configures integral gain for slip control.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t ki = 100;
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetSlipIntegralGain(&ACIM_FREQ_CTRL_0, ki);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetSlipIntegralGain(ACIM_FREQ_CTRL_t*const HandlePtr,uint32_t ki);

/**
 * @brief Returns configured integral gain used for slip control.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t Configured integral gain used for slip control.
 * <BR>
 * \par<b>Description: </b><br>
 * Returns configured integral gain used for slip control.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint16_t ki;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ki = ACIM_FREQ_CTRL_GetSlipIntegralGain(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetSlipIntegralGain(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Set proportional gain for current limit block.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param kp uint32_t proportional gain
 * @return ACIM_FREQ_CTRL_STATUS_t Returns success if \a kp is in valid range
 * <BR>
 * \par<b>Description: </b><br>
 * This function set proportional gain for current limit block.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t kp = 100;
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetCurrentProportionalGain(&ACIM_FREQ_CTRL_0, kp);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetCurrentProportionalGain(ACIM_FREQ_CTRL_t*const HandlePtr,uint32_t kp);
/**
 * @brief Return the current proportional gain used for current limit block.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t Proportional gain used for current limit block
 * <BR>
 * \par<b>Description: </b><br>
 * This function return the current proportional gain used for current limit block.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t current_kp;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   current_kp = ACIM_FREQ_CTRL_GetCurrentProportionalGain(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetCurrentProportionalGain(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Set integral gain for current limit block.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param ki uint32_t input value
 * @return ACIM_FREQ_CTRL_STATUS_t Returns success if \a ki is in valid range
 * <BR>
 * \par<b>Description: </b><br>
 * This function set integral gain for current limit block.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint16_t ki = 100;
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetCurrentIntegralGain(&ACIM_FREQ_CTRL_0, ki);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetCurrentIntegralGain(ACIM_FREQ_CTRL_t*const HandlePtr,uint32_t ki);

/**
 * @brief Return the current integral gain used for current limit block.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t integral gain used for current limit block.
 * <BR>
 * \par<b>Description: </b><br>
 * This function return the current integral gain used for current limit block.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t current_Ki;
 *   DAVE_STATUS_t init_status;
 *   init_status= DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   current_Ki = ACIM_FREQ_CTRL_GetCurrentIntegralGain(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetCurrentIntegralGain(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Updates the position reference for position control block.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param position_set int32_t input reference position set \n
 * MSB two bytes hold the number of revolution \n
 * LSB two bytes hold angle
 * @return ACIM_FREQ_CTRL_STATUS_t status of operation.<br>
 * ACIM_FREQ_CTRL_STATUS_SUCCESS if set value is successful <br>
 * ACIM_FREQ_CTRL_STATUS_INVALID_PARAM if \a position_set is not within the limit.<br>
 * ACIM_FREQ_CTRL_STATUS_PERMISSION_DENIED if write_access is set to not allowed - position control is disabled<br>
 * <BR>
 * \par<b>Description: </b><br>
 * Updates the position reference for position control block.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   int32_t position_set = 0x1FFFF; // two revolution
 *   DAVE_STATUS_t init_status;
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetPosition(&ACIM_FREQ_CTRL_0, position_set);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetPosition(ACIM_FREQ_CTRL_t*const HandlePtr,int32_t position_set);
/**
 * @brief Return the current reference position used in position control block.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return int32_t position set
 * <BR>
 * \par<b>Description: </b><br>
 * This API return the current reference position used in position control block.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t position_value;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   position_value = ACIM_FREQ_CTRL_GetPosition(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
int32_t ACIM_FREQ_CTRL_GetPosition(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Set the current limit for current limit block.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param current_value uint32_t input current limit
 *
 * @return ACIM_FREQ_CTRL_STATUS_t Returns success if \a current_value is in valid range
* <BR>
* \par<b>Description: </b><br>
* This API set the current limit for current limit block.\n
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint16_t current_value = 100;
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetCurrentLimit(&ACIM_FREQ_CTRL_0, current_value);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetCurrentLimit(ACIM_FREQ_CTRL_t*const HandlePtr,uint32_t current_value);
/**
 * @brief Returns configured current limit in current limit block.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t Configured current limit in current limit block.
* <BR>
* \par<b>Description: </b><br>
* Returns configured current limit in current limit block.
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t curren_limit;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   curren_limit = ACIM_FREQ_CTRL_GetCurrentLimit(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetCurrentLimit(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Set the PWM frequency.
 * This API update all PWM frequency dependent parameters.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param freq_value uint32_t frequency input
 *
 * @return ACIM_FREQ_CTRL_STATUS_t
 *
 * \par<b>Description: </b><br>
 * This API set the PWM frequency.Frequency can be updated only if motor is stopped
 * or else this operation is not allowed.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 *
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t freq_value = 25000;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_SetPWMFrequency(&ACIM_FREQ_CTRL_0, freq_value);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetPWMFrequency(ACIM_FREQ_CTRL_t*const HandlePtr,uint32_t freq_value);
/**
 * @brief Return the current PWM frequency of the APP.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t configured frequency
 * <BR>
 * \par<b>Description: </b><br>
 * This function return the current PWM frequency of the APP.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t freq_value;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   freq_value = ACIM_FREQ_CTRL_GetPWMFrequency(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetPWMFrequency(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Set the angle offset.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param angle_value uint32_t input angle offset
 *
 * @return ACIM_FREQ_CTRL_STATUS_t
 * <BR>
 * \par<b>Description: </b><br>
 * This API set the angle offset.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_SetAngleoffset(&ACIM_FREQ_CTRL_0, 5);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */

ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetAngleoffset(ACIM_FREQ_CTRL_t*const HandlePtr,uint32_t angle_value);
/**
 * @brief Return the offset angle value.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t Offset angle
 * <BR>
 * \par<b>Description: </b><br>
 * This function return the offset angle value.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t angle_value;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   angle_value = ACIM_FREQ_CTRL_GetAngleoffset(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetAngleoffset(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Set the amplitude offset.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param amp_value uint32_t input amplitude value
 *
 * @return ACIM_FREQ_CTRL_STATUS_t
 * <BR>
 * \par<b>Description: </b><br>
 * This API set the amplitude offset.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   init_status= DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetAmplitudeoffset(&ACIM_FREQ_CTRL_0, 100);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetAmplitudeoffset(ACIM_FREQ_CTRL_t*const HandlePtr,uint32_t amp_value);
/**
 * @brief Return the amplitude offset value.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t Amplitude offset
 * <BR>
 * \par<b>Description: </b><br>
 * This function return the amplitude offset value.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t amp_value;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   amp_value = ACIM_FREQ_CTRL_GetAmplitudeoffset(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
uint32_t ACIM_FREQ_CTRL_GetAmplitudeoffset(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Set the additive position.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param position_value uint32_t position input
 *
 * @return ACIM_FREQ_CTRL_STATUS_t
 * <BR>
 * \par<b>Description: </b><br>
 * This API set the additive position.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetAdditivePosition(&ACIM_FREQ_CTRL_0, 45);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */

ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetAdditivePosition(ACIM_FREQ_CTRL_t*const HandlePtr,int32_t position_value);
/**
 * @brief Return the additive position.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @return uint32_t Additive position
 * <BR>
 * \par<b>Description: </b><br>
 * This function return the additive position.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   int32_t position_value;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   position_value = ACIM_FREQ_CTRL_GetAdditivePosition(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
int32_t ACIM_FREQ_CTRL_GetAdditivePosition(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Set the additive speed value.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle
 * @param speed_value int32_t input additive speed
 *
 * @return ACIM_FREQ_CTRL_STATUS_t
 * <BR>
 * \par<b>Description: </b><br>
 * This API set the additive speed value.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   ACIM_FREQ_CTRL_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   status = ACIM_FREQ_CTRL_SetAdditiveSpeed(&ACIM_FREQ_CTRL_0, 100);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */

ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetAdditiveSpeed(ACIM_FREQ_CTRL_t*const HandlePtr,int32_t speed_value);
/**
 * @brief Return the additive speed value.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle
 * @return uint32_t
 * <BR>
 * \par<b>Description: </b><br>
 * This function return the additive speed value.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   int32_t speed_value;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   speed_value = ACIM_FREQ_CTRL_GetAdditiveSpeed(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
int32_t ACIM_FREQ_CTRL_GetAdditiveSpeed(ACIM_FREQ_CTRL_t*const HandlePtr);
/**
 * @brief Change the actual position input to user defined position input.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @param ref_address This is the address of variable, which hold the user defined position value.
 * @return void
 * <BR>
 * \par<b>Description: </b><br>
 * This API change the actual position input to user defined position input.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_position_value = Reading using hall sensors;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_ActualPositionUpdate(&ACIM_FREQ_CTRL_0,&actual_position_value);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */void ACIM_FREQ_CTRL_ActualPositionUpdate(ACIM_FREQ_CTRL_t*const HandlePtr, int32_t* ref_address);
/**
 * @brief Change the actual speed input to user defined speed input.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle.
 * @param ref_address This is the address of variable, which hold the user defined actual speed value.
 * @return void
 * <BR>
 * \par<b>Description: </b><br>
 * This API change the actual speed input to user defined speed input.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_speed_value = Reading using hall sensors;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_ActualSpeedUpdate(&ACIM_FREQ_CTRL_0,&actual_speed_value);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_ActualSpeedUpdate(ACIM_FREQ_CTRL_t*const HandlePtr, int32_t* ref_address);
/**
 * @brief Change the actual current input to user defined current input.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle.
 * @param ref_address This is the address of variable, which hold the user defined current value.
 * @return void
 * <BR>
 * \par<b>Description: </b><br>
 * This API change the actual current input to user defined current input.
* <BR>
* \par<b>Example Usage: </b><br>
* <BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_ActualCurrentUpdate(&ACIM_FREQ_CTRL_0,&actual_current_value);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_ActualCurrentUpdate(ACIM_FREQ_CTRL_t*const HandlePtr, int32_t* ref_address);

/**
 * @}
 */




/*
 * @brief This function related to drive state machine. This function is called while drive state enter into
 * SwitchedOff. Motor stop function is called from this function.
 * @param HandlePtr Constant pointer to ACIM_FREQ_CTRL APP Handle.
 * @return void
 * <BR>
 *
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_SwitchedOff_Entry(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_SwitchedOff_Entry (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state in
 * SwitchedOff state. Motor stop function is called from this function.
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_SwitchedOff_Action(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_SwitchedOff_Action (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state exit from
 * SwitchedOff.
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_SwitchedOff_Exit(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_SwitchedOff_Exit(void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state enter into
 * safe torque off state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Safe_Torque_Off_Entry(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Safe_Torque_Off_Entry (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state in
 * safe torque off state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Safe_Torque_Off_Action(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Safe_Torque_Off_Action (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state exit from
 * safe torque off state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Safe_Torque_Off_Exit(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Safe_Torque_Off_Exit(void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state enter in
 * enable state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Enabled_Action(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Enabled_Action (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state exit from
 * enable state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Enabled_Exit(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Enabled_Exit(void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state  in
 * switch on state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Switched_On_Action(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Switched_On_Action (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state enter into
 * operation state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Operation_Entry(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Operation_Entry (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state exit from
 * operation state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Operation_Exit(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Operation_Exit (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state enter into
 * coast stop state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Coast_Stop_Entry(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Coast_Stop_Entry (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state exit into
 * coast stop state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Coast_Stop_Exit(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Coast_Stop_Exit (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state enter into
 * quick stop state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Quick_Stop_Entry(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Quick_Stop_Entry (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state exit into
 * quick stop state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Quick_Stop_Exit(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Quick_Stop_Exit (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state enter into
 * ramp down state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Rampdown_Entry(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Rampdown_Entry (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state enter in
 * ramp down state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Rampdown_Action(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Rampdown_Action (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state enter into
 * error state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Error_Entry(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Error_Entry (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state enter in
 * error state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Error_Action(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Error_Action (void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state exit from
 * error state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Error_Exit(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Error_Exit(void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state  in
 * operation state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Operation_Action(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Operation_Action(void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state  in
 * coast stop state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Coast_Stop_Action(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Coast_Stop_Action(void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state  in
 * quick stop state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Quick_Stop_Action(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Quick_Stop_Action(void* HandlePtr);
/*
 * @brief This function related to drive state machine. This function is called while drive state  in
 * trouble state
 * @param[in] HandlePtr Constant pointer to ACIM_FREQ_CTRL app Handle.
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 * @code
 * #include <DAVE.h>
 * int main (void)
 * {
 *   uint32_t actual_current_value = Reading using ADC;
 *   DAVE_Init();   //ACIM_FREQ_CTRL_Init is called within DAVE_Init
 *   ACIM_FREQ_CTRL_DSM_Trouble_Action(&ACIM_FREQ_CTRL_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void ACIM_FREQ_CTRL_DSM_Trouble_Action(void* HandlePtr);
/*
 * Function to update the error handler
 */
void ACIM_FREQ_CTRL_UpdateError(ACIM_FREQ_CTRL_t* const HandlePtr, const ACIM_FREQ_CTRL_EID_t error_num);

#include "acim_freq_ctrl_extern.h"


/* Support for C++ codebase */
#ifdef __cplusplus
}
#endif

#endif /* ACIM_FREQ_CTRL_H_ */
