/**
 * @file acim_freq_ctrl.c
 * @date 2015-10-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * ACIM_FREQ_CTRL v4.0.7 - Supports frequency control- constant V/f Control\nfor the AC induction motor (ACIM).
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version
 *
 * 2015-02-20:
 *     - MotorParamInit - reset PI buffer value
 *
 * 2015-10-08:
 *     - CPU_CTRL_XMCx APP init function call removed.
 *
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "acim_freq_ctrl.h"
/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#if (UC_SERIES == XMC13)
/*ADC work around code*/
#define ADC_AI0040    ( *(uint32_t*) 0x480340E0 )
#define ADC_AI0041    ( *(uint32_t*) 0x480340E4 )
#endif
/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
#if (ACIM_FREQ_CTRL_IS_ADC_AVAILABLE == 1U)
/**
 * @brief This function do the ADC configurations
 * @param[in] HandlePtr Handler of the ACIM_FREQ_CTRL App
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */

ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_ADCConfig(ACIM_FREQ_CTRL_ADCConfig_t*const HandlePtr);
#endif
/**
 * @brief This function calibrates the amplifier bias voltage.
 * @param[in] HandlePtr Handler pointer of ACIM_FREQ_CTRL App
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
void ACIM_FREQ_CTRL_AmpBiasVoltCalibration(ACIM_FREQ_CTRL_t* const HandlePtr);

/**
 * @brief This function initialize  channel-1 compare value before starting of boot strap.
 * @param[in] HandlePtr Handler pointer of ACIM_FREQ_CTRL App
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
void ACIM_FREQ_CTRL_BootStrapConfiguration(ACIM_FREQ_CTRL_t* const HandlePtr);
/**
 * @brief This function do the ISR configuration.
 * @param[in] HandlePtr Handler of the ISR module of ACIM_FREQ_CTRL App
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
static void ACIM_FREQ_CTRL_ISRInit(ACIM_FREQ_CTRL_ISRHandle_t* const HandlePtr);
/**
 * @brief This function initialize the run time parameters of motor.
 * @param[in] HandlePtr Handler pointer of ACIM_FREQ_CTRL App
 * @return void
 * <BR>
 */
static void ACIM_FREQ_CTRL_MotorParamInit(ACIM_FREQ_CTRL_t* const HandlePtr);
/*
 * Function Initializes the required variable after init
 */
void ACIM_FREQ_CTRL_lInitializeVarAfterInit(ACIM_FREQ_CTRL_t* const HandlePtr);
#if (ACIM_FREQ_CTRL_IS_AUTOMATION_AVAILABLE == 1U)
/*
 * Function register for SVP and PCL task
 */
void ACIM_FREQ_CTRL_lTaskSchedulerRegisteration(ACIM_FREQ_CTRL_t*const HandlePtr,ACIM_FREQ_CTRL_TASKREGISTER_PTR_t task_function_ptr,
    const ACIM_FREQ_CTRL_EID_t error_num,uint32_t task_time);
#endif
/*
 * Function updates task scheduler times for frequency update API
 */
void ACIM_FREQ_CTRL_lTaskSchedulerTimeUpdate(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t frequency_value);
#if (ACIM_FREQ_CTRL_IS_ADC_AVAILABLE == 1U)
/*
 * Function updates queue entry
 */
void ACIM_FREQ_CTRL_lADCQueueEntry(ACIM_FREQ_CTRL_ADCConfig_t *const HandlePtr,uint8_t active_queue);
#endif
/**
 * @brief This function initialize the automation app.
 * @param[in] HandlePtr Handler pointer of ACIM_FREQ_CTRL App
 * @return void
 * <BR>
 */
#if (ACIM_FREQ_CTRL_IS_AUTOMATION_AVAILABLE == 1U)
static ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_Automation_Init(ACIM_FREQ_CTRL_t*const HandlePtr);
#endif

/**
 * @brief This is local function. Call by the APIs to set the parameter value.
 * @param[in] HandlePtr Handler pointer of ACIM_FREQ_CTRL App
 * @param[in] param_value This is required value to be set
 * @param[in] param_id Handler pointer of ACIM_FREQ_CTRL App
 * @return ACIM_FREQ_CTRL_STATUS_t status of the API
 * <BR>
 */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetParameter(ACIM_FREQ_CTRL_t* const HandlePtr, int32_t param_value,
                                                    ACIM_FREQ_CTRL_PID_t param_id);
/*
 * Function Initializes for ISR
 */
void ACIM_FREQ_CTRL_lISRInit(ACIM_FREQ_CTRL_t* const HandlePtr);

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
void ACIM_FREQ_CTRL_lInitializeVarAfterInit(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  /* Initialize current limit input if current limit is enabled */
  if ((HandlePtr->acim_config_ptr->enable_iavg_actcurrent == (uint16_t) 1)
      && (HandlePtr->acim_config_ptr->enable_current_limit == (uint16_t) 1))
  {
    /* Initialize current control actual input */
    HandlePtr->current_limit_ptr->input_ptr = &HandlePtr->motor_current;
  }
  /* Initialize position input and speed reference, if position control is enabled */
  if (HandlePtr->acim_config_ptr->enable_position_control == (uint16_t) 1)
  {
    HandlePtr->speed_set_ptr = &HandlePtr->position_control_ptr->output;
  }
}
void ACIM_FREQ_CTRL_lISRInit(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  /* ISR Init for fast control loop */
  ACIM_FREQ_CTRL_ISRInit(HandlePtr->fcl_config_ptr);

  if (HandlePtr->acim_config_ptr->pcl_task_conf == (uint8_t) ACIM_FREQ_CTRL_TS_PCL_ISR)
  {
    /* ISR Init for primary control loop */
    ACIM_FREQ_CTRL_ISRInit(HandlePtr->pcl_config_ptr);
  }
}
/*
 * This function configure the the NVIC Node.
 */
static void ACIM_FREQ_CTRL_ISRInit(ACIM_FREQ_CTRL_ISRHandle_t* const HandlePtr)
{
  /*set the priority and sub priority*/
#if (UC_FAMILY == XMC1)
  NVIC_SetPriority((IRQn_Type) HandlePtr->node_id, (uint32_t) HandlePtr->priority);
#else
  NVIC_SetPriority((IRQn_Type)HandlePtr->node_id,
      NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
          (uint32_t)HandlePtr->priority,(uint32_t)HandlePtr->sub_priority));
#endif
  /*Enable the IRQ*/
  NVIC_EnableIRQ((IRQn_Type) HandlePtr->node_id);
}

static void ACIM_FREQ_CTRL_MotorParamInit(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  HandlePtr->amplitude = 0U;
  HandlePtr->angle = 0U;
  HandlePtr->overcurrent_counter = 0U;
  HandlePtr->bootstrap_index = 0U;
  if (HandlePtr->acim_config_ptr->enable_slip_control == 1U)
  {
    HandlePtr->slip_control_ptr->pi_ptr->i_buf = 0;
  }
  if (HandlePtr->acim_config_ptr->enable_current_limit == 1U)
  {
    HandlePtr->current_limit_ptr->pi_ptr->i_buf = 0;
  }
  if (HandlePtr->acim_config_ptr->enable_position_control == 1U)
  {
    HandlePtr->position_control_ptr->pi_ptr->i_buf = 0;
  }

  /*Changing write access for pwm frequency to not allowed*/
  HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_PWM_FREQUENCY].write_access =
      (uint8_t) ACIM_FREQ_CTRL_PH_WA_NOT_ALLOWED;

#if (ACIM_FREQ_CTRL_IS_AUTOMATION_AVAILABLE == 1U)
  /*Ramp parameter Init*/
  if (NULL != HandlePtr->ramp_fb_ptr)
  {
    AUTOMATION_FB_RampInit (HandlePtr->ramp_fb_ptr);
  }
#endif
}

#if (ACIM_FREQ_CTRL_IS_AUTOMATION_AVAILABLE == 1U)
static ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_Automation_Init(ACIM_FREQ_CTRL_t*const HandlePtr)
{
  uint32_t status;
  uint32_t fb_connect_status = (uint32_t)ACIM_FREQ_CTRL_STATUS_SUCCESS;

  status = (uint32_t)AUTOMATION_Init(HandlePtr->automation_ptr);

  /* Register App */
  status |= (uint32_t)AUTOMATION_RegisterApp (HandlePtr, HandlePtr->acim_freq_ctrl_fb_ptr->name, &HandlePtr->app_id);

  /* register task */
  if ((uint32_t)ACIM_FREQ_CTRL_STATUS_SUCCESS == status)
  {
#if (ACIM_FREQ_CTRL_IS_DSM_AVAILABLE == 1U)
    if (HandlePtr->acim_config_ptr->dsm_task_conf == (uint8_t)ACIM_FREQ_CTRL_TS_AUTOMATION)
    {
      status |=(uint32_t)AUTOMATION_SM_RegisterStateMachine( HandlePtr->acim_statemachine ,HandlePtr->app_id);
      status |= (uint32_t)AUTOMATION_RegisterTask((AUTOMATION_TASK_FUNCT_PTR_t)HandlePtr->dsm_function_ptr,
          (AUTOMATION_SM_t*)(void*)HandlePtr->acim_statemachine,HandlePtr->dsm_time);
    }
#endif

#if (AUTOMATION_PH_ENABLE == 1U)
    /* register app parameter table in automation framework*/
    status |= (uint32_t)AUTOMATION_PH_RegisterParamTable(HandlePtr->app_id,
        (AUTOMATION_PH_PARAM_ENTRY_t*)(void*)HandlePtr->param_table_ptr);
#endif

    /* Function block */
    status |= (uint32_t)AUTOMATION_FB_RegisterFunctionBlock(HandlePtr->acim_freq_ctrl_fb_ptr);

    if (NULL != HandlePtr->ramp_fb_ptr)
    {
      /* Connect ramp function block with ACIM_FREQ function block */
      fb_connect_status = (uint32_t)AUTOMATION_FB_AddConnectionEntry(HandlePtr->acim_freq_ctrl_fb_ptr, (uint8_t)ACIM_FREQ_CTRL_FB_OUT_USER_SPEED,
          HandlePtr->ramp_fb_ptr, (uint8_t)AUTOMATION_FB_IN_SIGNAL_ENDREF);
      if ((uint32_t)ACIM_FREQ_CTRL_STATUS_SUCCESS != fb_connect_status)
      {
        AUTOMATION_FB_Connect();
        fb_connect_status = (uint32_t)AUTOMATION_FB_AddConnectionEntry(HandlePtr->acim_freq_ctrl_fb_ptr, (uint8_t)ACIM_FREQ_CTRL_FB_OUT_USER_SPEED,
            HandlePtr->ramp_fb_ptr, (uint8_t)AUTOMATION_FB_IN_SIGNAL_ENDREF);
      }

      fb_connect_status |= (uint32_t)AUTOMATION_FB_AddConnectionEntry(HandlePtr->acim_freq_ctrl_fb_ptr, (uint8_t)ACIM_FREQ_CTRL_FB_OUT_SPEED_SCALE,
          HandlePtr->ramp_fb_ptr, (uint8_t)AUTOMATION_FB_IN_SIGNAL_SCALE);

      fb_connect_status |= (uint32_t)AUTOMATION_FB_AddConnectionEntry(HandlePtr->ramp_fb_ptr, (uint8_t)AUTOMATION_FB_OUT_SIGNAL_REF,
          HandlePtr->acim_freq_ctrl_fb_ptr, (uint8_t)ACIM_FREQ_CTRL_FB_IN_SPEED_REF);
      AUTOMATION_FB_Connect();
    }
  }

  return (ACIM_FREQ_CTRL_STATUS_t)(status | fb_connect_status);
}
#endif


/* Returns the version of the ACIM_FREQ_CTRL App. */
DAVE_APP_VERSION_t ACIM_FREQ_CTRL_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = ACIM_FREQ_CTRL_MAJOR_VERSION;
  version.minor = ACIM_FREQ_CTRL_MINOR_VERSION;
  version.patch = ACIM_FREQ_CTRL_PATCH_VERSION;

  return version;
}

/* Initialise ACIM_FREQ_CTRL app parameters and low level apps*/
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_Init(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  ACIM_FREQ_CTRL_STATUS_t status = ACIM_FREQ_CTRL_STATUS_SUCCESS;

  if ((uint8_t) ACIM_FREQ_CTRL_UNINITIALISED == HandlePtr->state)
  {
    /* ADC Configuration for measurement */
#if (ACIM_FREQ_CTRL_IS_ADC_AVAILABLE == 1U)
    if (NULL != HandlePtr->adc_config_ptr)
    {
      if (ACIM_FREQ_CTRL_STATUS_FAILURE == ACIM_FREQ_CTRL_ADCConfig(HandlePtr->adc_config_ptr))
      {
        status = ACIM_FREQ_CTRL_STATUS_FAILURE;
      }
    }
#endif
    /* AUTOMATION app initialisation */
#if (ACIM_FREQ_CTRL_IS_AUTOMATION_AVAILABLE == 1U)
    if (1U == HandlePtr->acim_config_ptr->enable_automation)
    {
      if ((uint8_t)ACIM_FREQ_CTRL_STATUS_FAILURE == (uint8_t)ACIM_FREQ_CTRL_Automation_Init(HandlePtr))
      {
        status = ACIM_FREQ_CTRL_STATUS_FAILURE;
      }
    }
#endif
    ACIM_FREQ_CTRL_lISRInit(HandlePtr);

    /* PWM SVM Init */
    if ((uint8_t) ACIM_FREQ_CTRL_STATUS_FAILURE == (uint8_t) PWM_SVM_Init(HandlePtr->pwm_svm_ptr))
    {
      status = ACIM_FREQ_CTRL_STATUS_FAILURE;
    }
    if (status != ACIM_FREQ_CTRL_STATUS_FAILURE)
    {
      ACIM_FREQ_CTRL_lInitializeVarAfterInit(HandlePtr);
      HandlePtr->state = (uint8_t) ACIM_FREQ_CTRL_INITIALISED;
    }
    else
    {
      ACIM_FREQ_CTRL_UpdateError(HandlePtr, ACIM_FREQ_CTRL_EID_INIT_FAILED);
    }
  }
  return (status);
}

#if (ACIM_FREQ_CTRL_IS_ADC_AVAILABLE == 1U)
void ACIM_FREQ_CTRL_lADCQueueEntry(ACIM_FREQ_CTRL_ADCConfig_t *const HandlePtr,uint8_t active_queue)
{
  uint8_t queue_entry_num;
  /*Insertion of queue entry for conversion*/
  for(queue_entry_num = 0U; queue_entry_num <= 3U; queue_entry_num++)
  {
    if (NULL != HandlePtr->queue_entry_hdlarray[queue_entry_num][active_queue])
    {
      if (NULL != HandlePtr->vadc_chhandle_array[queue_entry_num])
      {
        HandlePtr->vadc_chhandle_array[queue_entry_num]->input_class =
        (uint8_t)HandlePtr->qapp_handlearray[active_queue]->iclass_num;
      }
      ADC_QUEUE_InsertQueueEntry(HandlePtr->qapp_handlearray[active_queue],
          HandlePtr->queue_entry_hdlarray[queue_entry_num][active_queue]);
    }
  }
}
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_ADCConfig(ACIM_FREQ_CTRL_ADCConfig_t *const HandlePtr)
{
  uint8_t active_queue;
#if (ACIM_FREQ_CTRL_ADC_CALIBRATION == 1U)
#if (UC_SERIES == XMC13)
  uint32_t adc_calib = 0x11U;
  uint32_t Count;
#endif
#endif
  ACIM_FREQ_CTRL_STATUS_t adc_status = ACIM_FREQ_CTRL_STATUS_FAILURE;
  /*Queue App initialization*/
  for(active_queue = 0U;active_queue < 4U;active_queue++)
  {
    if ((uint8_t)ACIM_FREQ_CTRL_QUEUE_ACTIVE == HandlePtr->queue_active[active_queue])
    {
      adc_status = (ACIM_FREQ_CTRL_STATUS_t)ADC_QUEUE_Init(HandlePtr->qapp_handlearray[active_queue]);
    }

    /*channel initialization*/
    if (NULL != HandlePtr->vadc_chhandle_array[active_queue])
    {
      XMC_VADC_GROUP_ChannelInit(HandlePtr->vadc_group_pointerarray[active_queue],
          (uint32_t)HandlePtr->channel_num_array[active_queue],
          HandlePtr->vadc_chhandle_array[active_queue]);
    }
    /*Result initialization*/
    if (NULL != HandlePtr->vadc_reshandle_array[active_queue])
    {
      XMC_VADC_GROUP_ResultInit(HandlePtr->vadc_group_pointerarray[active_queue],
          (uint32_t)HandlePtr->result_num_array[active_queue],
          HandlePtr->vadc_reshandle_array[active_queue]);
    }

    if ((uint8_t)ACIM_FREQ_CTRL_QUEUE_ACTIVE == HandlePtr->queue_active[active_queue])
    {
      ACIM_FREQ_CTRL_lADCQueueEntry(HandlePtr,active_queue);
#if (ACIM_FREQ_CTRL_ADC_CALIBRATION == 1U)
#if (UC_SERIES == XMC13)
      /*ADC work around code */
      VADC -> GLOBCFG = 0x80038000;
      for(Count=0U;Count<1000U;Count++)
      {
        ;
      }
      adc_calib = adc_calib<<SHS_SHSCFG_STATE_Pos;
      while( (SHS0->SHSCFG & SHS_SHSCFG_STATE_Msk) == adc_calib)
      {
        ;
      }
      ADC_AI0040 = 0x80008000;
      ADC_AI0041 = 0x80008000;
#endif
#endif
      ADC_QUEUE_AllEntriesInserted(HandlePtr->qapp_handlearray[active_queue]);
    }
  }
  return (adc_status);
}
#endif
/* Report error */
void ACIM_FREQ_CTRL_UpdateError(ACIM_FREQ_CTRL_t* const HandlePtr, const ACIM_FREQ_CTRL_EID_t error_num)
{
  /* Log the operational error */
  HandlePtr->operational_error |= ((uint32_t) 1 << (uint32_t) error_num);
  /* Set the error status in error table */
  HandlePtr->error_table_ptr[error_num].error_status = (uint8_t) ACIM_FREQ_CTRL_ERROR_SET;
  if (HandlePtr->error_table_ptr[error_num].error_handler_ptr_t != NULL)
  {
    /* Call the function to take action for timeout */
    (HandlePtr->error_table_ptr[error_num].error_handler_ptr_t)(HandlePtr);
  }
}
#if (ACIM_FREQ_CTRL_IS_AUTOMATION_AVAILABLE == 1U)
void ACIM_FREQ_CTRL_lTaskSchedulerRegisteration(ACIM_FREQ_CTRL_t*const HandlePtr,ACIM_FREQ_CTRL_TASKREGISTER_PTR_t task_function_ptr,
    const ACIM_FREQ_CTRL_EID_t error_num,uint32_t task_time)
{
  if ((uint32_t)ACIM_FREQ_CTRL_STATUS_FAILURE == (uint32_t)AUTOMATION_RegisterTask((AUTOMATION_TASK_FUNCT_PTR_t)task_function_ptr,(ACIM_FREQ_CTRL_t*)HandlePtr,
          task_time))
  {
    ACIM_FREQ_CTRL_UpdateError(HandlePtr,error_num);
  }
  else
  {
    if (error_num == ACIM_FREQ_CTRL_EID_SVP_REG_FAILED)
    {
      HandlePtr->registered_task_svp = 1U;
    }
    else if (error_num == ACIM_FREQ_CTRL_EID_PCL_REG_FAILED)
    {
      HandlePtr->registered_task_pcl = 1U;
    }
  }
}
#endif
void ACIM_FREQ_CTRL_MotorStart(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  /* Motor State machine should be in STOP state to start the motor.
   * In case of any error, motor start function won't be started
   * until clear all the errors.
   */
  if (HandlePtr->msm_state == ACIM_FREQ_CTRL_MSM_STOP)
  {
#if (ACIM_FREQ_CTRL_IS_DSM_AVAILABLE == 1U)
    if ((HandlePtr->acim_config_ptr->dsm_task_conf == (uint8_t)ACIM_FREQ_CTRL_TS_DISABLED)||
        ( HandlePtr->acim_statemachine->current_state == (uint8_t)ACIM_FREQ_CTRL_DSM_OPERATION))
    {
      /*Start the motor, if Drive State machine is in Operation state*/
      HandlePtr->msm_state = ACIM_FREQ_CTRL_MSM_INIT_INVERTER;
    }
    if ((HandlePtr->acim_config_ptr->dsm_task_conf != (uint8_t)ACIM_FREQ_CTRL_TS_DISABLED) &&
        ( HandlePtr->acim_statemachine->current_state != (uint8_t)ACIM_FREQ_CTRL_DSM_OPERATION))
    {
      HandlePtr->cw_state =ACIM_FREQ_CTRL_CW_AUTOMATIC_ON;
    }
#else
    HandlePtr->msm_state = ACIM_FREQ_CTRL_MSM_INIT_INVERTER;
#endif
    /* check the MSM state */
    if (HandlePtr->msm_state == ACIM_FREQ_CTRL_MSM_INIT_INVERTER)
    {
#if (ACIM_FREQ_CTRL_IS_AUTOMATION_AVAILABLE == 1U)
      /* Register set value process function to automation framework, based on user configuration */
      if ((HandlePtr->acim_config_ptr->svp_task_conf == (uint8_t)ACIM_FREQ_CTRL_TS_AUTOMATION ) &&
          (HandlePtr->registered_task_svp == 0U))
      {
        ACIM_FREQ_CTRL_lTaskSchedulerRegisteration(HandlePtr,HandlePtr->svp_function_ptr,ACIM_FREQ_CTRL_EID_SVP_REG_FAILED,
            HandlePtr->svp_time);
      }
      /* Register primary control loop function to automation framework, based on user configuration */
      if ((HandlePtr->acim_config_ptr->pcl_task_conf == (uint8_t)ACIM_FREQ_CTRL_TS_AUTOMATION) &&
          (HandlePtr->registered_task_pcl == 0U))
      {
        ACIM_FREQ_CTRL_lTaskSchedulerRegisteration(HandlePtr,HandlePtr->pcl_function_ptr,ACIM_FREQ_CTRL_EID_PCL_REG_FAILED,
            HandlePtr->pcl_time);
      }
#endif
      ACIM_FREQ_CTRL_MSM(HandlePtr);
    }
  }
}

void ACIM_FREQ_CTRL_MotorStop(ACIM_FREQ_CTRL_t* const HandlePtr)
{
#if (ACIM_FREQ_CTRL_IS_AUTOMATION_AVAILABLE == 1U)
  uint8_t status = (uint8_t)ACIM_FREQ_CTRL_STATUS_SUCCESS;
#endif
  /*stop pwm svm*/
  PWM_SVM_Stop(HandlePtr->pwm_svm_ptr);
  /*disable inverter*/
  PWM_SVM_InverterDisable(HandlePtr->pwm_svm_ptr);

  /*Changing write access for pwm frequency to allowed*/
  HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_PWM_FREQUENCY].write_access = (uint8_t) ACIM_FREQ_CTRL_PH_WA_ALLOWED;

#if (ACIM_FREQ_CTRL_IS_AUTOMATION_AVAILABLE == 1U)
  /* deregister Primary Control Loop function to automation framework, based on user configuration */
  if ((HandlePtr->acim_config_ptr->pcl_task_conf == (uint8_t)ACIM_FREQ_CTRL_TS_AUTOMATION)
      &&(HandlePtr->registered_task_pcl == 1U))
  {
    status = (uint8_t)AUTOMATION_DeregisterTask((AUTOMATION_TASK_FUNCT_PTR_t)HandlePtr->pcl_function_ptr);
    if ((uint8_t)ACIM_FREQ_CTRL_STATUS_FAILURE == status)
    {
      ACIM_FREQ_CTRL_UpdateError(HandlePtr, ACIM_FREQ_CTRL_EID_PCL_REG_FAILED);
    }
    else
    {
      HandlePtr->registered_task_pcl = 0U;
    }

  }
  /* deregister Set value process function to automation framework, based on user configuration */
  if ((HandlePtr->acim_config_ptr->svp_task_conf == (uint8_t)ACIM_FREQ_CTRL_TS_AUTOMATION)
      &&(HandlePtr->registered_task_svp == 1U))
  {
    status = (uint8_t)AUTOMATION_DeregisterTask((AUTOMATION_TASK_FUNCT_PTR_t)HandlePtr->svp_function_ptr);
    if ((uint8_t)ACIM_FREQ_CTRL_STATUS_FAILURE == status)
    {
      ACIM_FREQ_CTRL_UpdateError(HandlePtr, ACIM_FREQ_CTRL_EID_SVP_REG_FAILED);
    }
    else
    {
      HandlePtr->registered_task_svp = 0U;
    }
  }
#endif
  if (((HandlePtr->operational_error & 0x1FU) != 0U))
  {
    HandlePtr->msm_state = ACIM_FREQ_CTRL_MSM_ERROR;
    /*call the motor state machine, to report the error*/
    ACIM_FREQ_CTRL_MSM(HandlePtr);
  }
  else
  {
    /* Change motor control state machine to stop */
    HandlePtr->msm_state = ACIM_FREQ_CTRL_MSM_STOP;
  }
}

ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetParameter(ACIM_FREQ_CTRL_t* const HandlePtr, int32_t param_value,
                                                    ACIM_FREQ_CTRL_PID_t param_id)
{
  ACIM_FREQ_CTRL_PT_ENTRY_t *param_ptr = &HandlePtr->param_table_ptr[param_id];
  ACIM_FREQ_CTRL_STATUS_t status = ACIM_FREQ_CTRL_STATUS_SUCCESS;
  if (param_ptr->write_access == (uint8_t) ACIM_FREQ_CTRL_PH_WA_ALLOWED)
  {
    if ((param_value >= param_ptr->minval) && (param_value <= param_ptr->maxval))
    {
      *param_ptr->param_value = (int32_t)(
          ((int64_t) param_value * (int64_t) param_ptr->inv_scale) / (int64_t) ACIM_FREQ_CTRL_POWER215);
    }
    else
    {
      status = ACIM_FREQ_CTRL_STATUS_INVALID_PARAM;
    }
  }
  else
  {
    status = ACIM_FREQ_CTRL_STATUS_PERMISSION_DENIED;
  }
  return status;
}

/* This API update the end speed of the motor */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetSpeed(ACIM_FREQ_CTRL_t* const HandlePtr, int32_t speed)
{
  ACIM_FREQ_CTRL_STATUS_t status;
  /*set the speed and return the status*/
  status = ACIM_FREQ_CTRL_SetParameter(HandlePtr, speed, ACIM_FREQ_CTRL_PID_SPEED_REF);
  /*set the motor direction based on the speed*/
  if (HandlePtr->user_speed_set < 0)
  {
    HandlePtr->motor_direction = (int8_t) ACIM_FREQ_CTRL_ANTICLOCKWISE_DIR;
  }
  else
  {
    HandlePtr->motor_direction = (int8_t) ACIM_FREQ_CTRL_CLOCKWISE_DIR;
  }
  return status;
}

/* This API update return the current speed of the motor */
int32_t ACIM_FREQ_CTRL_GetSpeed(ACIM_FREQ_CTRL_t * const HandlePtr)
{
  int32_t speed;
  speed = (int32_t)(
      ((int64_t)(*HandlePtr->speed_set_ptr) * (int64_t) HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_SPEED_REF].scale)
          / 32767);
  return (int32_t) speed;
}

/* This API update the voltage constant of the motor */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetVoltageConstant(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t volt_constant)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) volt_constant, ACIM_FREQ_CTRL_PID_VOLT_CONSTANT);
}

/* This API return the voltage constant of the motor */
uint32_t ACIM_FREQ_CTRL_GetVoltageConstant(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(
      ((uint64_t) HandlePtr->vf_control_ptr->vf_constant
          * HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_VOLT_CONSTANT].scale) >> ACIM_FREQ_CTRL_Q15);
}

/* This API set the voltage offset of the motor */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetVoltageOffset(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t volt_offset)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) volt_offset, ACIM_FREQ_CTRL_PID_VOLT_OFFSET);
}
/* This API return the voltage offset of the motor */
uint32_t ACIM_FREQ_CTRL_GetVoltageOffset(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(
      ((uint64_t) HandlePtr->vf_control_ptr->vf_offset
          * HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_VOLT_OFFSET].scale) >> ACIM_FREQ_CTRL_Q15);
}

/* This API direction of the motor */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetMotorDirection(ACIM_FREQ_CTRL_t* const HandlePtr,
                                                         ACIM_FREQ_CTRL_MD_t direction)
{
  ACIM_FREQ_CTRL_STATUS_t status = ACIM_FREQ_CTRL_STATUS_SUCCESS;
  if (HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_MOTOR_DIR].write_access == (uint8_t) ACIM_FREQ_CTRL_PH_WA_ALLOWED)
  {
    if ((direction == ACIM_FREQ_CTRL_CLOCKWISE_DIR) || (direction == ACIM_FREQ_CTRL_ANTICLOCKWISE_DIR))
    {
      HandlePtr->motor_direction = (int8_t) direction;

      if ((HandlePtr->user_speed_set < 0) && (HandlePtr->motor_direction == (int8_t) ACIM_FREQ_CTRL_CLOCKWISE_DIR))
      {
        HandlePtr->user_speed_set = (int32_t)(-1 * HandlePtr->user_speed_set);
      }
      else if ((HandlePtr->user_speed_set > 0)
          && (HandlePtr->motor_direction == (int8_t) ACIM_FREQ_CTRL_ANTICLOCKWISE_DIR))
      {
        HandlePtr->user_speed_set = (int32_t)(-1 * HandlePtr->user_speed_set);
      }
      else
      {
      }
    }
    else
    {
      status = ACIM_FREQ_CTRL_STATUS_INVALID_PARAM;
    }
  }
  else
  {
    status = ACIM_FREQ_CTRL_STATUS_PERMISSION_DENIED;
  }
  return status;
}
/* This API return the motor direction */
int32_t ACIM_FREQ_CTRL_GetMotorDirection(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (int32_t)(HandlePtr->motor_direction);
}

/* This API set the control word state */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetControlWordState(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t control_word)
{
  ACIM_FREQ_CTRL_STATUS_t status = ACIM_FREQ_CTRL_STATUS_SUCCESS;
  ACIM_FREQ_CTRL_PT_ENTRY_t* param_ptr = &HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_CW_STATE];
  if (param_ptr->write_access == (uint8_t) ACIM_FREQ_CTRL_PH_WA_ALLOWED)
  {
    if ((control_word >= (uint32_t) param_ptr->minval) && (control_word <= (uint32_t) param_ptr->maxval))
    {
      HandlePtr->cw_state = (ACIM_FREQ_CTRL_CW_t) control_word;
    }
    else
    {
      status = ACIM_FREQ_CTRL_STATUS_INVALID_PARAM;
    }

  }
  else
  {
    status = ACIM_FREQ_CTRL_STATUS_PERMISSION_DENIED;
  }
  return status;
}

/* This API get the control word state */
uint32_t ACIM_FREQ_CTRL_GetControlWordState(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(HandlePtr->cw_state);
}

/* This API set the over current limit */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetOverCurrentLimit(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t over_current_val)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) over_current_val, ACIM_FREQ_CTRL_PID_OC_LIMIT);
}

/* This API return the over current limit */
uint32_t ACIM_FREQ_CTRL_GetOverCurrentLimit(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(
      ((uint64_t) HandlePtr->overcurrent_limit * HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_OC_LIMIT].scale)
          >> ACIM_FREQ_CTRL_Q15);
}

/* This API set the voltage limit. Input is in % of 0x3FFF amplitude. */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetVoltLimit(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t voltlimitval)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) voltlimitval, ACIM_FREQ_CTRL_PID_VOLT_LIMIT);
}

/* This API return the voltage limit in % of maximum amplitude,0x3FFF. */
uint32_t ACIM_FREQ_CTRL_GetVoltLimit(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(
      ((uint64_t) HandlePtr->voltage_limit * HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_VOLT_LIMIT].scale)
          >> ACIM_FREQ_CTRL_Q15);
}

/* This API set the Position control Kp value */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetPositionProportionalGain(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t kp)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) kp, ACIM_FREQ_CTRL_PID_POSITION_KP);
}

/* This API return the Position control Kp value */
uint32_t ACIM_FREQ_CTRL_GetPositionProportionalGain(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(
      ((uint64_t) HandlePtr->position_control_ptr->pi_ptr->kp
          * HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_POSITION_KP].scale) >> ACIM_FREQ_CTRL_Q15);
}
/* This API set the Position control Ki value */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetPositionIntegralGain(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t ki)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) ki, ACIM_FREQ_CTRL_PID_POSITION_KI);
}

/* This API return the Position control Ki value */
uint32_t ACIM_FREQ_CTRL_GetPositionIntegralGain(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(
      ((uint64_t) HandlePtr->position_control_ptr->pi_ptr->ki
          * HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_POSITION_KI].scale) >> ACIM_FREQ_CTRL_Q15);
}

/* This API set slip control Kp value */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetSlipProportionalGain(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t kp)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) kp, ACIM_FREQ_CTRL_PID_SLIP_KP);
}

/* This API return the slip control Kp value */
uint32_t ACIM_FREQ_CTRL_GetSlipProportionalGain(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(
      ((uint64_t) HandlePtr->slip_control_ptr->pi_ptr->kp * HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_SLIP_KP].scale)
          >> ACIM_FREQ_CTRL_Q15);
}
/* This API set the slip control Ki value */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetSlipIntegralGain(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t ki)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) ki, ACIM_FREQ_CTRL_PID_SLIP_KI);
}

/* This API return the slip control Ki value */
uint32_t ACIM_FREQ_CTRL_GetSlipIntegralGain(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(
      ((uint64_t) HandlePtr->slip_control_ptr->pi_ptr->ki * HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_SLIP_KI].scale)
          >> ACIM_FREQ_CTRL_Q15);
}

/* This API set the current limit Kp value */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetCurrentProportionalGain(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t kp)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) kp, ACIM_FREQ_CTRL_PID_CURRENT_KP);
}

/* This API return the current limit Kp value  */
uint32_t ACIM_FREQ_CTRL_GetCurrentProportionalGain(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(
      ((uint64_t) HandlePtr->current_limit_ptr->pi_ptr->kp
          * HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_CURRENT_KP].scale) >> ACIM_FREQ_CTRL_Q15);
}
/* This API set the current limit Ki value  */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetCurrentIntegralGain(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t ki)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) ki, ACIM_FREQ_CTRL_PID_CURRENT_KI);
}

/* This API return the current limit Ki value  */
uint32_t ACIM_FREQ_CTRL_GetCurrentIntegralGain(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(
      ((uint64_t) HandlePtr->current_limit_ptr->pi_ptr->ki
          * HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_CURRENT_KI].scale) >> ACIM_FREQ_CTRL_Q15);
}

/* This API set the input reference position */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetPosition(ACIM_FREQ_CTRL_t* const HandlePtr, int32_t position_set)
{
  ACIM_FREQ_CTRL_STATUS_t status = ACIM_FREQ_CTRL_STATUS_SUCCESS;

  ACIM_FREQ_CTRL_PT_ENTRY_t *param_ptr = &HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_POSITION_REF];

  if (param_ptr->write_access == (uint8_t) ACIM_FREQ_CTRL_PH_WA_ALLOWED)
  {
    if ((position_set >= param_ptr->minval) && (position_set <= param_ptr->maxval))
    {
      *param_ptr->param_value = (int32_t) position_set;
    }
    else
    {
      status = ACIM_FREQ_CTRL_STATUS_INVALID_PARAM;
    }
  }
  else
  {
    status = ACIM_FREQ_CTRL_STATUS_PERMISSION_DENIED;
  }
  return status;

}

/* This API return the reference position value.
 * First two byte represent angle and last two byte represent the revolution.
 */
int32_t ACIM_FREQ_CTRL_GetPosition(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (int32_t)(HandlePtr->user_position_set);
}
/* This API set the current limit value */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetCurrentLimit(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t current_value)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) current_value, ACIM_FREQ_CTRL_PID_CURRENT_LIMIT);
}

/* This API return the current limit value */
uint32_t ACIM_FREQ_CTRL_GetCurrentLimit(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(
      ((uint64_t) HandlePtr->current_limit_ptr->current_limit
          * HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_CURRENT_LIMIT].scale) >> ACIM_FREQ_CTRL_Q15);
}
void ACIM_FREQ_CTRL_lTaskSchedulerTimeUpdate(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t frequency_value)
{
  /*Update pcl and msm time */
  if ((HandlePtr->acim_config_ptr->pcl_task_conf == (uint8_t) ACIM_FREQ_CTRL_TS_DISABLED)
      || (HandlePtr->acim_config_ptr->pcl_task_conf == (uint8_t) ACIM_FREQ_CTRL_TS_SW_DIV)
      || (HandlePtr->acim_config_ptr->pcl_task_conf == (uint8_t) ACIM_FREQ_CTRL_TS_PCL_ISR))
  {
    /*Update pcl time */
    HandlePtr->pcl_time = ((1000000U * HandlePtr->acim_config_ptr->pcl_divider) / frequency_value);
    /*Update msm time */
    HandlePtr->msm_time = HandlePtr->pcl_time;
    /*Update svp time */
    if (HandlePtr->acim_config_ptr->svp_task_conf == (uint8_t) ACIM_FREQ_CTRL_TS_PCL_TASK)
    {
      HandlePtr->svp_time = HandlePtr->pcl_time;
    }
  }

  /*Update svp time if it dont use PCL_ISR time*/
  if ((HandlePtr->acim_config_ptr->svp_task_conf == (uint8_t) ACIM_FREQ_CTRL_TS_DISABLED)
      || (HandlePtr->acim_config_ptr->svp_task_conf == (uint8_t) ACIM_FREQ_CTRL_TS_SW_DIV))
  {
    /*Update svp time */
    HandlePtr->svp_time = ((1000000U * HandlePtr->acim_config_ptr->svp_divider) / frequency_value);
  }
}
/* This API set the PWM frequency and update the related parameters(angle_scale and bootstrap_count). */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetPWMFrequency(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t frequency_value)
{
  ACIM_FREQ_CTRL_PT_ENTRY_t* param_ptr = &HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_PWM_FREQUENCY];
  uint32_t status = (uint32_t) ACIM_FREQ_CTRL_STATUS_SUCCESS;
  if (param_ptr->write_access == (uint8_t) ACIM_FREQ_CTRL_PH_WA_ALLOWED)
  {
    if (HandlePtr->msm_state == ACIM_FREQ_CTRL_MSM_STOP)
    {
      if ((frequency_value >= (uint32_t) param_ptr->minval) && (frequency_value <= (uint32_t) param_ptr->maxval))
      {
        /* Update the pwm frequency */
        HandlePtr->pwm_frequency = frequency_value;
        status = (uint32_t) PWM_SVM_SetPWMFrequency(HandlePtr->pwm_svm_ptr, frequency_value);
        if (frequency_value != 0U)
        {
          /* Update angle scale */
          HandlePtr->angle_scale = ((((HandlePtr->acim_config_ptr->nominal_speed
              * HandlePtr->acim_config_ptr->fcl_divider * HandlePtr->acim_config_ptr->pole_pair) <<
          ACIM_FREQ_CTRL_VFSCALE) / (frequency_value * 60U)) << 8U);

          ACIM_FREQ_CTRL_lTaskSchedulerTimeUpdate(HandlePtr, frequency_value);

        }
        /* Update bootstrap count*/
        HandlePtr->bootstrap_count = (uint16_t)(
            ((uint32_t) HandlePtr->acim_config_ptr->bootstrap_time * frequency_value) / 1000U);

      }
      else
      {
        status = (uint32_t) ACIM_FREQ_CTRL_STATUS_INVALID_PARAM;
      }
    }
    else
    {
      status = (uint32_t) ACIM_FREQ_CTRL_STATUS_OPERATION_NOT_ALLOWED;
    }
  }
  else
  {
    status = (uint32_t) ACIM_FREQ_CTRL_STATUS_PERMISSION_DENIED;
  }
  return (ACIM_FREQ_CTRL_STATUS_t) status;
}

/* This API return the PWM frequency value */
uint32_t ACIM_FREQ_CTRL_GetPWMFrequency(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(PWM_SVM_GetPWMFrequency(HandlePtr->pwm_svm_ptr));
}

ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetAngleoffset(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t angle_value)
{
  ACIM_FREQ_CTRL_STATUS_t status = ACIM_FREQ_CTRL_STATUS_SUCCESS;
  ACIM_FREQ_CTRL_PT_ENTRY_t* param_ptr = &HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_ANGLE_OFFSET];
  if (param_ptr->write_access == (uint8_t) ACIM_FREQ_CTRL_PH_WA_ALLOWED)
  {
    if ((angle_value >= (uint32_t) param_ptr->minval) && (angle_value <= (uint32_t) param_ptr->maxval))
    {
      HandlePtr->angle_offset = (angle_value * param_ptr->inv_scale);
    }
    else
    {
      status = ACIM_FREQ_CTRL_STATUS_INVALID_PARAM;
    }
  }
  else
  {
    status = ACIM_FREQ_CTRL_STATUS_PERMISSION_DENIED;
  }
  return status;
}
uint32_t ACIM_FREQ_CTRL_GetAngleoffset(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(
      (HandlePtr->angle_offset * (HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_ANGLE_OFFSET].scale)) >> 24U);
}

ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetAmplitudeoffset(ACIM_FREQ_CTRL_t* const HandlePtr, uint32_t amp_value)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) amp_value, ACIM_FREQ_CTRL_PID_AMP_OFFSET);
}
uint32_t ACIM_FREQ_CTRL_GetAmplitudeoffset(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (uint32_t)(
      ((uint64_t) HandlePtr->amplitude_offset * HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_AMP_OFFSET].scale)
          >> ACIM_FREQ_CTRL_Q15);
}

ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetAdditivePosition(ACIM_FREQ_CTRL_t* const HandlePtr, int32_t position_value)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) position_value, ACIM_FREQ_CTRL_PID_ADDITIVE_POS);
}

int32_t ACIM_FREQ_CTRL_GetAdditivePosition(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  return (int32_t)(HandlePtr->position_control_ptr->additive_position);
}

/* This API update the additive speed of the slip control block */
ACIM_FREQ_CTRL_STATUS_t ACIM_FREQ_CTRL_SetAdditiveSpeed(ACIM_FREQ_CTRL_t* const HandlePtr, int32_t speed_value)
{
  return ACIM_FREQ_CTRL_SetParameter(HandlePtr, (int32_t) speed_value, ACIM_FREQ_CTRL_PID_ADDITIVE_SPEED);
}

/* This API update return the additive speed of the slip control block */
int32_t ACIM_FREQ_CTRL_GetAdditiveSpeed(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  int32_t speed;
  speed = (int32_t)(
      ((int64_t) HandlePtr->slip_control_ptr->additive_speed
          * (int64_t) HandlePtr->param_table_ptr[ACIM_FREQ_CTRL_PID_ADDITIVE_SPEED].scale)
          / (int32_t) ACIM_FREQ_CTRL_POWER215);
  return (int32_t) speed;

}
/* This API update the actual position input to user defined position input*/
void ACIM_FREQ_CTRL_ActualPositionUpdate(ACIM_FREQ_CTRL_t* const HandlePtr, int32_t* ref_address)
{
  HandlePtr->position_control_ptr->input_ptr = ref_address;
}
/* This API update the actual speed input to user defined speed input*/
void ACIM_FREQ_CTRL_ActualSpeedUpdate(ACIM_FREQ_CTRL_t* const HandlePtr, int32_t* ref_address)
{
  HandlePtr->slip_control_ptr->input_ptr = ref_address;
}
/* This API update the actual current input to user defined current input*/
void ACIM_FREQ_CTRL_ActualCurrentUpdate(ACIM_FREQ_CTRL_t* const HandlePtr, int32_t* ref_address)
{
  HandlePtr->current_limit_ptr->input_ptr = ref_address;
}


void ACIM_FREQ_CTRL_Amplitude_Calculation(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  int32_t temp_speed_ref;
  uint32_t temp_speed_value;
  ACIM_FREQ_CTRL_VF_t * const module_ptr = HandlePtr->vf_control_ptr;

  /*Amplitude Calculation*/
  temp_speed_ref = module_ptr->input;

  if (temp_speed_ref < 0)
  {
    temp_speed_ref = -1 * temp_speed_ref;
  }
  temp_speed_value = (uint32_t) temp_speed_ref;

  module_ptr->output_amplitude = (uint32_t)(
      ((temp_speed_value * (module_ptr->vf_constant)) >> ACIM_FREQ_CTRL_VFSCALE) + (module_ptr->vf_offset));

  if (module_ptr->output_amplitude > HandlePtr->voltage_limit)
  {
    module_ptr->output_amplitude = HandlePtr->voltage_limit;
  }
}
void ACIM_FREQ_CTRL_AngleRamp(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  uint32_t temp_input;
  temp_input = (uint32_t) HandlePtr->vf_control_ptr->input;
  temp_input = (HandlePtr->angle_scale * temp_input) >> 8U;
  /*Angle Calculation*/
  HandlePtr->vf_control_ptr->output_angle += (int32_t) temp_input;
}

void ACIM_FREQ_CTRL_CurrentLimit(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  volatile int32_t error;
  volatile int32_t signed_value;
  ACIM_FREQ_CTRL_CL_t * const module_ptr = HandlePtr->current_limit_ptr;
  signed_value = -1;
  /* Check for Negative Current value, if the current is negative, assign motor current as zero*/
  if ((*module_ptr->input_ptr) > (int32_t) ACIM_FREQ_CTRL_POWER215)
  {
    *module_ptr->input_ptr = 0;
  }
  /* If specified limit is higher than actual current */
  if (*module_ptr->input_ptr <= module_ptr->current_limit)
  {
    module_ptr->output = 0;
  }
  else /* If actual current higher than specified limit */
  {
    error = module_ptr->current_limit - (*module_ptr->input_ptr);

    MOTOR_LIB_PIController(module_ptr->pi_ptr, (int32_t) error);
    
    module_ptr->output = signed_value * module_ptr->pi_ptr->pi_out_val;

    if (*HandlePtr->speed_set_ptr < 0) /* Motor is running in Anti-Clockwise direction*/
    {
      module_ptr->output = signed_value * module_ptr->output;

      if (module_ptr->output < *HandlePtr->speed_set_ptr)
      {
        module_ptr->output = *HandlePtr->speed_set_ptr;
      }
    }
    else
    {
      if (module_ptr->output > *HandlePtr->speed_set_ptr)
      {
        module_ptr->output = *HandlePtr->speed_set_ptr;
      }
    }
  }
}

void ACIM_FREQ_CTRL_BootStrapConfiguration(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  volatile uint8_t phase_count;
  PWM_SVM_t * const module_ptr = HandlePtr->pwm_svm_ptr;

  /*BootStrapping*/
  for (phase_count = (uint8_t) 0; phase_count < (uint8_t) 3; phase_count++)
  {
    /* Update channel 1 compare value (CR1) of slice */
    XMC_CCU8_SLICE_SetTimerCompareMatch(module_ptr->phase_ptr[phase_count]->slice_ptr,
        (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) 0xFFFFU);
    /*Disable PWM Asymmetrical, if this is enabled*/
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[phase_count]->slice_ptr, 0x1E0014U);
  }

  /*Enable the shadow transfer for all three consumed slice*/
  XMC_CCU8_EnableShadowTransfer(module_ptr->global_ptr, module_ptr->confighandle_ptr->shadow_transfer_mask);
}

#if (ACIM_FREQ_CTRL_IS_ADC_AVAILABLE == 1U)
uint16_t ACIM_FREQ_CTRL_GetCurrentValue(ACIM_FREQ_CTRL_t*const HandlePtr)
{
  uint16_t current_value;
  /*
   * Read current.
   */
  current_value = (uint16_t)(((XMC_VADC_GROUP_GetResult(HandlePtr->adc_config_ptr->vadc_group_pointerarray[0],
                  (uint32_t)HandlePtr->adc_config_ptr->result_num_array[0]))*4U) & 0x3FFFU) - HandlePtr->ampoffset;

  /* Check for Negative Current value, if the current is negative, assign motor current as zero*/
  if (current_value > (uint16_t)ACIM_FREQ_CTRL_POWER215)
  {
    current_value = 0U;
  }
  return current_value;
}

void ACIM_FREQ_CTRL_OverCurrentDetection(ACIM_FREQ_CTRL_t*const HandlePtr)
{
  /*
   * If over current detection is enable and over current is detected then stop
   * the motor.
   */
  if (HandlePtr->acim_config_ptr->enable_over_current == (uint16_t)1)
  {
    /* motor  current higher than specified limit */
    if (HandlePtr->motor_current > (int16_t)HandlePtr->overcurrent_limit)
    {
      /*increment the counter*/
      HandlePtr->overcurrent_counter++;
      /* if counter reached the specified limit*/
      if (HandlePtr->overcurrent_counter >= ACIM_FREQ_CTRL_MAX_OC_COUNTER)
      {
        ACIM_FREQ_CTRL_UpdateError(HandlePtr,ACIM_FREQ_CTRL_EID_OVERCURRENT);
      }
    }
    /* if motor 'current' is not higher than the specified limit*/
    else
    {
      if (HandlePtr->overcurrent_counter > (uint16_t)0)
      {
        /*decrement the counter*/
        HandlePtr->overcurrent_counter--;
      }
    }
  }
}

void ACIM_FREQ_CTRL_VoltageCompensation(ACIM_FREQ_CTRL_t*const HandlePtr)
{
  MOTOR_LIB_PT1Controller(HandlePtr->voltcomp_filter_ptr,(int32_t)HandlePtr->dclink_voltage);

  if (HandlePtr->voltcomp_filter_ptr->pt1_out_val != 0)
  {
    /*Do the voltage compensation based on dc link value*/
    HandlePtr->amplitude =
    (uint32_t)(((uint32_t)HandlePtr->amplitude * HandlePtr->acim_config_ptr->specified_volt)/((uint16_t)HandlePtr->voltcomp_filter_ptr->pt1_out_val));
  }
}

void ACIM_FREQ_CTRL_PotMeasurement(ACIM_FREQ_CTRL_t*const HandlePtr)
{
  uint32_t pot_value;
  /* Read pot */
  pot_value = (uint32_t)(XMC_VADC_GROUP_GetResult(HandlePtr->adc_config_ptr->vadc_group_pointerarray[2],
          (uint32_t)HandlePtr->adc_config_ptr->result_num_array[2])) & 0xFFFU;

  pot_value = pot_value<<ACIM_FREQ_CTRL_POTSCALE;

  /* Calculate speed */
  HandlePtr->user_speed_set = (int32_t)pot_value*HandlePtr->motor_direction;

}

void ACIM_FREQ_CTRL_AmpBiasVoltCalibration(ACIM_FREQ_CTRL_t*const HandlePtr)
{
  uint16_t amp_offset = 0U;
  volatile uint32_t amp_offset_buf =0U;
  volatile uint32_t count;

  /* Current Amplifier bias voltage calibration and Current measurement are enable
   * Calculate the current amplifier bias voltage  */
  if (((uint16_t)1 == HandlePtr->acim_config_ptr->enable_biasvoltage)&&
      ((uint16_t)1 == HandlePtr->acim_config_ptr->enable_avg_current))
  {
    /* ADC bias voltage measurement */
    for(count = 0U; count < ACIM_FREQ_CTRL_ADCCAL_COUNT; count++)
    {
      XMC_VADC_GROUP_QueueTriggerConversion(HandlePtr->adc_config_ptr->vadc_group_pointerarray[0]);

      amp_offset = (uint16_t)((XMC_VADC_GROUP_GetResult(HandlePtr->adc_config_ptr->vadc_group_pointerarray[0],
                  (uint32_t)HandlePtr->adc_config_ptr->result_num_array[0])) & 0xFFFU);

      amp_offset_buf += amp_offset;
    }
    HandlePtr->ampoffset = (uint16_t)((amp_offset_buf/ACIM_FREQ_CTRL_ADCCAL_COUNT)<<2U);
  }
  else
  {
    HandlePtr->ampoffset = HandlePtr->acim_config_ptr->current_amplifier_offset;
  }
}
#endif

void ACIM_FREQ_CTRL_StartPWMTimer(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  volatile uint8_t phase_count;
  PWM_SVM_t* const module_ptr = HandlePtr->pwm_svm_ptr;

  for (phase_count = (uint8_t) 0; phase_count < (uint8_t) 3; phase_count++)
  {
    /* configure the Start trigger function*/
    XMC_CCU8_SLICE_StartConfig(module_ptr->phase_ptr[phase_count]->slice_ptr,
        (XMC_CCU8_SLICE_EVENT_t) XMC_CCU8_SLICE_EVENT_0,
        (XMC_CCU8_SLICE_START_MODE_t) XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
  }
  /* synchronous start of CCU8 slices */
  XMC_SCU_SetCcuTriggerHigh(module_ptr->confighandle_ptr->sync_start_mask);
  for (phase_count = (uint8_t) 0; phase_count < (uint8_t) 3; phase_count++)
  {
    /* configure the Start trigger function*/
    XMC_CCU8_SLICE_StartConfig(module_ptr->phase_ptr[phase_count]->slice_ptr,
        (XMC_CCU8_SLICE_EVENT_t) XMC_CCU8_SLICE_EVENT_NONE,
        (XMC_CCU8_SLICE_START_MODE_t) XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
  }
}

void ACIM_FREQ_CTRL_StopPWMTimer(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  /* synchronous stop of CCU8 slices */
  XMC_SCU_SetCcuTriggerLow(HandlePtr->pwm_svm_ptr->confighandle_ptr->sync_start_mask);
}

void ACIM_FREQ_CTRL_PositionControl(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  volatile int32_t pi_error;

  ACIM_FREQ_CTRL_PC_t * const module_ptr = HandlePtr->position_control_ptr;

  module_ptr->position_set += module_ptr->additive_position;
  
  pi_error = (int32_t)(module_ptr->position_set - (int32_t) * module_ptr->input_ptr);

  if (pi_error > 0x7FFF)
  {
    pi_error = 0x7FFF;
  }
  else if (pi_error < -0x7FFF)
  {
    pi_error = -0x7FFF;
  }
  else
  {
  }
  /*Position control based on PI technique*/
  MOTOR_LIB_PIController(module_ptr->pi_ptr, (int32_t) pi_error);

  module_ptr->output = module_ptr->pi_ptr->pi_out_val;
}

void ACIM_FREQ_CTRL_SlipControl(ACIM_FREQ_CTRL_t * const HandlePtr)
{
  ACIM_FREQ_CTRL_SC_t * const module_ptr = HandlePtr->slip_control_ptr;

  module_ptr->speed_set += module_ptr->additive_speed;

  /*Slip Control based on PI technique*/
  MOTOR_LIB_PIController(module_ptr->pi_ptr, (int32_t)(module_ptr->speed_set - (int32_t) * module_ptr->input_ptr));

  module_ptr->output = module_ptr->pi_ptr->pi_out_val;
}

/* Motot control state machine*/
void ACIM_FREQ_CTRL_MSM(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  switch (HandlePtr->msm_state)
  {
    case ACIM_FREQ_CTRL_MSM_INIT_INVERTER:

      /*Initialize all run time parameters*/
      ACIM_FREQ_CTRL_MotorParamInit(HandlePtr);

      /*Current amplifier bias voltage calibration*/
#if (ACIM_FREQ_CTRL_IS_ADC_AVAILABLE == 1U)
      ACIM_FREQ_CTRL_AmpBiasVoltCalibration(HandlePtr);
#endif

      /*Start PWM Timer to run the Motor State Machine*/
      ACIM_FREQ_CTRL_StartPWMTimer(HandlePtr);

      /*Enable inverter*/
      PWM_SVM_InverterEnable(HandlePtr->pwm_svm_ptr);

      if (HandlePtr->bootstrap_count != 0U)
      {
        /*Boot strap Configuration */
        ACIM_FREQ_CTRL_BootStrapConfiguration(HandlePtr);
        /*Change Motor Control State Machine to Boot Strap*/
        HandlePtr->msm_state = ACIM_FREQ_CTRL_MSM_BOOTSTRAP;
      }
      else
      {
        HandlePtr->msm_state = ACIM_FREQ_CTRL_MSM_START_UP;
      }
      break;

    case ACIM_FREQ_CTRL_MSM_BOOTSTRAP:
      if (ACIM_FREQ_CTRL_BOOTSTRAP_COMPLETED == ACIM_FREQ_CTRL_BootStrap(HandlePtr))
      {
        HandlePtr->msm_state = ACIM_FREQ_CTRL_MSM_START_UP;

      }
      break;

    case ACIM_FREQ_CTRL_MSM_START_UP:

      /*Stop the PWM timer*/
      ACIM_FREQ_CTRL_StopPWMTimer(HandlePtr);

      /*Start SVM*/
      PWM_SVM_Start(HandlePtr->pwm_svm_ptr);

      /*Change Motor Control State Machine to Operation*/
      HandlePtr->msm_state = ACIM_FREQ_CTRL_MSM_NORMAL_OPERATION;
      break;

    case ACIM_FREQ_CTRL_MSM_LOW_SPEED:
      break;

    case ACIM_FREQ_CTRL_MSM_TRANSITION:
      break;

    case ACIM_FREQ_CTRL_MSM_NORMAL_OPERATION:

      if ((HandlePtr->operational_error & 0x1FU) != 0U)
      {
        HandlePtr->msm_state = ACIM_FREQ_CTRL_MSM_ERROR;
      }
      break;

    case ACIM_FREQ_CTRL_MSM_ERROR:
      /*Report error to error handler*/
      ACIM_FREQ_CTRL_ReportError(HandlePtr);
#if (ACIM_FREQ_CTRL_IS_DSM_AVAILABLE == 1U)
      if ((uint8_t)ACIM_FREQ_CTRL_TS_DISABLED != HandlePtr->acim_config_ptr->dsm_task_conf)
      {
        AUTOMATION_SM_RequestState(HandlePtr->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_ERROR);
      }
#endif
      break;

    case ACIM_FREQ_CTRL_MSM_STOP:
      ACIM_FREQ_CTRL_MotorStop(HandlePtr);
      break;

    default:
      break;
  }
}

void ACIM_FREQ_CTRL_ReportError(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  uint8_t count;
  for (count = (uint8_t) 0; count < (uint8_t) ACIM_FREQ_CTRL_EID_MAX; count++)
  {
    if (HandlePtr->error_table_ptr[count].error_status == (uint8_t) ACIM_FREQ_CTRL_ERROR_SET)
    {
#if ((ACIM_FREQ_CTRL_IS_AUTOMATION_AVAILABLE == 1U) && (AUTOMATION_EH_ENABLE == 1U))
      AUTOMATION_EH_AppInterface_ReportError(HandlePtr->app_id, HandlePtr->error_table_ptr[count].error_id,
          (AUTOMATION_EH_ERROR_SEVERITY_t)HandlePtr->error_table_ptr[count].error_severity,(AUTOMATION_EH_ERROR_STATUS_t)HandlePtr->error_table_ptr[count].error_status);
#endif
    }
  }
#if (ACIM_FREQ_CTRL_IS_ERROR_USER_CALLBACK_ENABLE == 1U)
  if ((uint16_t)1 == HandlePtr->acim_config_ptr->enable_error_callback)
  {
    ACIM_FREQ_CTRL_UserCodeErrorHandler(HandlePtr);
  }
#endif
}

ACIM_FREQ_CTRL_BOOTSTRAP_STATUS_t ACIM_FREQ_CTRL_BootStrap(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  ACIM_FREQ_CTRL_BOOTSTRAP_STATUS_t status = ACIM_FREQ_CTRL_BOOTSTRAP_ACTIVE;

  /*Enable Bootstrap for Phase U*/
  if (HandlePtr->bootstrap_index < HandlePtr->bootstrap_count)
  {
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[0U]->slice_ptr, 0x1E0000U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[1U]->slice_ptr, 0x1E0000U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[2U]->slice_ptr, 0x1E0000U);
  }
  /*Enable Bootstrap for Phase V*/
  else if (HandlePtr->bootstrap_index < (HandlePtr->bootstrap_count * 2U))
  {
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[0U]->slice_ptr, 0x1E0000U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[1U]->slice_ptr, 0x170000U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[2U]->slice_ptr, 0x1E0000U);
  }
  /*Enable Bootstrap for Phase W*/
  else if (HandlePtr->bootstrap_index < (HandlePtr->bootstrap_count * 3U))
  {
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[0U]->slice_ptr, 0x1E0000U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[1U]->slice_ptr, 0x1E0000U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[2U]->slice_ptr, 0x170000U);
  }
  else
  {
    /*Configure default value*/
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[0U]->slice_ptr, 0x170000U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[1U]->slice_ptr, 0x170000U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[2U]->slice_ptr, 0x170000U);
    status = ACIM_FREQ_CTRL_BOOTSTRAP_COMPLETED;
  }
  HandlePtr->bootstrap_index++;
  return (status);
}

void ACIM_FREQ_CTRL_ClearErrorState(ACIM_FREQ_CTRL_t* const HandlePtr)
{
  uint8_t count;
  for (count = (uint8_t) 0; count < (uint8_t) ACIM_FREQ_CTRL_EID_MAX; count++)
  {
    if (HandlePtr->error_table_ptr[count].error_status == (uint8_t) ACIM_FREQ_CTRL_ERROR_SET)
    {
      HandlePtr->error_table_ptr[count].error_status = (uint8_t) ACIM_FREQ_CTRL_ERROR_CLEARED;
#if ((ACIM_FREQ_CTRL_IS_AUTOMATION_AVAILABLE == 1U) && (AUTOMATION_EH_ENABLE == 1U))
      AUTOMATION_EH_AppInterface_ReportError(HandlePtr->app_id, HandlePtr->error_table_ptr[count].error_id,
          (AUTOMATION_EH_ERROR_SEVERITY_t)HandlePtr->error_table_ptr[count].error_severity,(AUTOMATION_EH_ERROR_STATUS_t)HandlePtr->error_table_ptr[count].error_status);
#endif
    }
  }
  HandlePtr->operational_error = 0U;

  HandlePtr->msm_state = ACIM_FREQ_CTRL_MSM_STOP;
}
#if (ACIM_FREQ_CTRL_IS_DSM_AVAILABLE == 1U)
void ACIM_FREQ_CTRL_DSM_SwitchedOff_Entry (void* HandlePtr)
{
  ACIM_FREQ_CTRL_MotorStop((ACIM_FREQ_CTRL_t*)HandlePtr);
}
void ACIM_FREQ_CTRL_DSM_SwitchedOff_Action (void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if (AppHandler->state == (uint8_t)ACIM_FREQ_CTRL_UNINITIALISED)
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_ERROR);
  }
  else
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_SAFE_TORQUE_OFF);
  }
}
void ACIM_FREQ_CTRL_DSM_SwitchedOff_Exit(void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if ((AppHandler->acim_statemachine->requested_state ==(uint8_t)ACIM_FREQ_CTRL_DSM_OPERATION )||
      (AppHandler->acim_statemachine->requested_state ==(uint8_t)ACIM_FREQ_CTRL_DSM_SWITCHED_ON ))
  {
    AppHandler->acim_statemachine->requested_state = AppHandler->acim_statemachine->current_state;
  }
}
void ACIM_FREQ_CTRL_DSM_Safe_Torque_Off_Entry (void* HandlePtr)
{
  ACIM_FREQ_CTRL_MotorStop((ACIM_FREQ_CTRL_t*)HandlePtr);
}
void ACIM_FREQ_CTRL_DSM_Safe_Torque_Off_Action (void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if (ACIM_FREQ_CTRL_CW_AUTOMATIC_ON == AppHandler->cw_state )
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_ENABLED);
  }
}
void ACIM_FREQ_CTRL_DSM_Safe_Torque_Off_Exit(void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if ((AppHandler->acim_statemachine->requested_state ==(uint8_t)ACIM_FREQ_CTRL_DSM_OPERATION )||
      (AppHandler->acim_statemachine->requested_state ==(uint8_t)ACIM_FREQ_CTRL_DSM_SWITCHED_ON ))
  {
    AppHandler->acim_statemachine->requested_state = AppHandler->acim_statemachine->current_state;
  }
}
void ACIM_FREQ_CTRL_DSM_Enabled_Action (void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if ((ACIM_FREQ_CTRL_CW_AUTOMATIC_ON == AppHandler->cw_state )||
      (ACIM_FREQ_CTRL_CW_ENABLE== AppHandler->cw_state))
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_SWITCHED_ON);
  }
}
void ACIM_FREQ_CTRL_DSM_Enabled_Exit(void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if (AppHandler->acim_statemachine->requested_state ==(uint8_t)ACIM_FREQ_CTRL_DSM_OPERATION )
  {
    AppHandler->acim_statemachine->requested_state = AppHandler->acim_statemachine->current_state;
  }
}
void ACIM_FREQ_CTRL_DSM_Switched_On_Action (void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if ((ACIM_FREQ_CTRL_CW_AUTOMATIC_ON == AppHandler->cw_state )||
      (ACIM_FREQ_CTRL_CW_OPERATE == AppHandler->cw_state))
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_OPERATION );
  }
}
void ACIM_FREQ_CTRL_DSM_Operation_Entry (void* HandlePtr)
{
  ACIM_FREQ_CTRL_MotorStart((ACIM_FREQ_CTRL_t*)HandlePtr);
}
void ACIM_FREQ_CTRL_DSM_Operation_Action(void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if (AppHandler->cw_state == ACIM_FREQ_CTRL_CW_RAMP_DOWN)
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_RAMP_DOWN);
  }
  else if (AppHandler->cw_state == ACIM_FREQ_CTRL_CW_COAST_STOP)
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_COAST_STOP);
  }
  else if (AppHandler->cw_state == ACIM_FREQ_CTRL_CW_QUICK_STOP)
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_QUICK_STOP);
  }
  else if (AppHandler->cw_state == ACIM_FREQ_CTRL_CW_SWITCH_ON)
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_SWITCHED_ON);
  }
  else
  {
  }
}
void ACIM_FREQ_CTRL_DSM_Operation_Exit(void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if ((AppHandler->acim_statemachine->requested_state ==(uint8_t)ACIM_FREQ_CTRL_DSM_ENABLED )||
      (AppHandler->acim_statemachine->requested_state ==(uint8_t)ACIM_FREQ_CTRL_DSM_SWITCHED_ON ))
  {
    AppHandler->acim_statemachine->requested_state = AppHandler->acim_statemachine->current_state;
  }
}
void ACIM_FREQ_CTRL_DSM_Coast_Stop_Entry (void* HandlePtr)
{
  ACIM_FREQ_CTRL_MotorStop((ACIM_FREQ_CTRL_t*)HandlePtr);
}
void ACIM_FREQ_CTRL_DSM_Coast_Stop_Action (void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if (AppHandler->cw_state == ACIM_FREQ_CTRL_CW_SWITCHED_OFF)
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_SWITCHED_OFF);
  }
}
void ACIM_FREQ_CTRL_DSM_Coast_Stop_Exit(void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if ((AppHandler->acim_statemachine->requested_state ==(uint8_t)ACIM_FREQ_CTRL_DSM_ENABLED )||
      (AppHandler->acim_statemachine->requested_state ==(uint8_t)ACIM_FREQ_CTRL_DSM_SWITCHED_ON )||
      (AppHandler->acim_statemachine->requested_state ==(uint8_t)ACIM_FREQ_CTRL_DSM_OPERATION ) )
  {
    AppHandler->acim_statemachine->requested_state = AppHandler->acim_statemachine->current_state;
  }
}
void ACIM_FREQ_CTRL_DSM_Quick_Stop_Entry (void* HandlePtr)
{
  ACIM_FREQ_CTRL_MotorStop((ACIM_FREQ_CTRL_t*)HandlePtr);
}
void ACIM_FREQ_CTRL_DSM_Quick_Stop_Action (void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if (AppHandler->cw_state == ACIM_FREQ_CTRL_CW_SWITCHED_OFF )
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_SWITCHED_OFF);
  }
}
void ACIM_FREQ_CTRL_DSM_Quick_Stop_Exit(void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if ((AppHandler->acim_statemachine->requested_state ==(uint8_t)ACIM_FREQ_CTRL_DSM_ENABLED )||
      (AppHandler->acim_statemachine->requested_state ==(uint8_t)ACIM_FREQ_CTRL_DSM_SWITCHED_ON )||
      (AppHandler->acim_statemachine->requested_state ==(uint8_t)ACIM_FREQ_CTRL_DSM_OPERATION ) )
  {
    AppHandler->acim_statemachine->requested_state = AppHandler->acim_statemachine->current_state;
  }
}
void ACIM_FREQ_CTRL_DSM_Rampdown_Entry (void* HandlePtr)
{
  ACIM_FREQ_CTRL_STATUS_t status;
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;

  status = ACIM_FREQ_CTRL_SetSpeed((ACIM_FREQ_CTRL_t*)HandlePtr,0);

  if (status != ACIM_FREQ_CTRL_STATUS_SUCCESS)
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_ERROR);
  }
}
void ACIM_FREQ_CTRL_DSM_Rampdown_Action (void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if (*AppHandler->speed_set_ptr == 0)
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_COAST_STOP);
  }
}
void ACIM_FREQ_CTRL_DSM_Error_Entry (void* HandlePtr)
{
  ACIM_FREQ_CTRL_MotorStop((ACIM_FREQ_CTRL_t*)HandlePtr);
}
void ACIM_FREQ_CTRL_DSM_Error_Action (void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if (ACIM_FREQ_CTRL_CW_ERROR_RESET ==AppHandler->cw_state )
  {
    ACIM_FREQ_CTRL_ClearErrorState(AppHandler);
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_SWITCHED_OFF);
  }
}
void ACIM_FREQ_CTRL_DSM_Error_Exit(void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if ((AppHandler->acim_statemachine->requested_state != (uint8_t)ACIM_FREQ_CTRL_DSM_SWITCHED_OFF ) &&
      (AppHandler->acim_statemachine->requested_state != (uint8_t)ACIM_FREQ_CTRL_DSM_USER_DEFINE_11 ) &&
      (AppHandler->acim_statemachine->requested_state != (uint8_t)ACIM_FREQ_CTRL_DSM_USER_DEFINE_12 ))
  {
    AppHandler->acim_statemachine->requested_state = AppHandler->acim_statemachine->current_state;
  }
  else
  {
    if (AppHandler->acim_statemachine->transition_request ==1U)
    {
      ACIM_FREQ_CTRL_ClearErrorState(AppHandler);
    }
  }
}
void ACIM_FREQ_CTRL_DSM_Trouble_Action(void* HandlePtr)
{
  ACIM_FREQ_CTRL_t* AppHandler = (ACIM_FREQ_CTRL_t*)HandlePtr;
  if (AppHandler->cw_state == ACIM_FREQ_CTRL_CW_ERROR)
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_ERROR);
  }
  else if (AppHandler->cw_state == ACIM_FREQ_CTRL_CW_RESUME_OPERATION)
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_OPERATION);
  }
  else if (AppHandler->cw_state == ACIM_FREQ_CTRL_CW_RESUME_SWITCHED_ON)
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_SWITCHED_ON);
  }
  else if (AppHandler->cw_state == ACIM_FREQ_CTRL_CW_RESUME_ENABLED)
  {
    AUTOMATION_SM_RequestState(AppHandler->acim_statemachine,(uint8_t)ACIM_FREQ_CTRL_DSM_ENABLED);
  }
  else
  {
  }
}
#endif

