/**
 * @file usbd_winusb.c
 * @date 2015-10-08
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * USBD_WINUSB v4.0.10 - The USBD_WINUSB is the Windows winusb.sys driver interface to the XMC4000 family of controllers.
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.                        
 *                                             
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the           
 * following conditions are met:   
 *                                                                              
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following   
 *   disclaimer.                        
 * 
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the    
 *   following disclaimer in the documentation and/or other materials provided with the distribution.     
 *                         
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote 
 *   products derived from this software without specific prior written permission. 
 *                                             
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,  
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE   
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,  
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR        
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,      
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE   
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    
 *                                                                              
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes       
 * with Infineon Technologies AG (dave@infineon.com).        
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version.      
 * 2015-03-18:
 *     - Guidelines updated.
 * 2015-04-23:
 *     - Updated the review comments from AEs.
 * 2015-06-20:
 *     - Updated the file header.
 *     
 * @endcond 
 *
 */


#ifndef USBD_WINUSB_H
#define USBD_WINUSB_H

/* Enable C linkage for C++ Compilers: */
#if defined(__cplusplus)
	extern "C" {
#endif

/***********************************************************************************************************************
 * HEADER FILES                                                                                                      
 **********************************************************************************************************************/
#include <xmc_common.h>
#include <DAVE_Common.h>
#include "../USBD/usbd.h"
#include "../USBD/usb/core/endpoint_stream.h"
#include "../USBD/usb/core/usb_task.h"
#include "./winusb/descriptors.h"
#include "../USBD/usb/core/endpoint.h"
#include "./usbd_winusb_conf.h"

/**********************************************************************************************************************
 * MACROS                                                                                                            
 **********************************************************************************************************************/

/**USBD_WINUSB RX buffer size*/
#define RX_BUF_SIZE 384U

/**USBD_WINUSB TX buffer size*/
#define TX_BUF_SIZE 384U

/**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
 /**
 * @ingroup USBD_WINUSB_enumerations
 * @{
 */

/**
 *WinUSB error codes
 */
typedef enum {
	USBD_WINUSB_STATUS_SUCCESS, /**< Operation was successful */
	USBD_WINUSB_STATUS_FAILURE, /**< Operation has raised an error */
	USBD_WINUSB_STATUS_NOT_READY /**< Device/Endpoint is not ready for operation */
} USBD_WINUSB_Status_t;

/**
 * @}
 */

/**********************************************************************************************************************
 * DATA STRUCTURES
 **********************************************************************************************************************/
/**
 * @ingroup USBD_WINUSB_datastructures
 * @{
 */
/**
 * \brief WinUSB Interface Information
 */
typedef struct {
	struct {
		USB_Endpoint_Table_t in_endpoint; /**< IN Endpoint Configuration */
		USB_Endpoint_Table_t out_endpoint; /**< OUT Endpoint Configuration */
	} config;
} USBD_WINUSB_Info_t;

/**
 * The structure contains the configuration parameters for USBD_WINUSB APP handle.
 * Currently this is a dummy handle and configuration parameters can be added later, if required.
 **/
typedef struct USBD_WINUSB
{
	uint8_t dummy;/**< The dummy variable to avoid compilation error on non GCC compilers*/
}USBD_WINUSB_t;

/**
 * @}
 */


extern USBD_WINUSB_Info_t winusb_info;

#include "usbd_winusb_extern.h"

/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/**
 * @ingroup USBD_WINUSB_apidoc
 * @{
 */
/**
 * @brief Initializes the USB core layer to make the device ready to connect to USB host.
 * @param winusb_handle Pointer to WINUSB device handle ::USBD_WINUSB_t
 * @return ::USBD_WINUSB_Status_t
 *
 * \par<b>Description:</b><br>
 *       This function :\n
 *       1) Registers the USB Device Events.\n
 *       2) Initializes the USB core driver.\n
 * The USBD_WINUSB_Init() is called inside the DAVE_Init().\n
 * \par<b>Note:</b><br>
 * The ::USBD_WINUSB_Connect() needs to be called from user application to connect to the USBD host or to trigger the USB enumeration.\n\n
 * Example Usage:
 * As part of DAVE_Init(), the USBD_WINUSB_Init() is invoked and user does not have to explicitly call the API USBD_WINUSB_Init().\n
 * Please see the example code for ::USBD_WINUSB_Connect API for the application code.
 */
USBD_WINUSB_Status_t USBD_WINUSB_Init(USBD_WINUSB_t *winusb_handle);


/**
 * @brief Connects the USB device to WINUSB host.
 * @param None
 * @return ::USBD_WINUSB_Status_t
 *
 * \par<b>Description:</b><br>
 *        The enumeration process is triggered by USBD_WINUSB_Connect() call.\n
 *        In order to call USBD_WINUSB_Connect()  following procedure should be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) Call USBD_WINUSB_Connect().\n
 * The USBD_WINUSB_Connect() call triggers the standard and class/vendor requests from the USB host, which need to be \n
 * handled by the WINUSB device.
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   uint8_t led = 0;
 *   uint16_t bytes;
 *
 *   DAVE_Init();			// Initialization of DAVE APPs
 *
 *
 *   if (USBD_WINUSB_Connect() != USBD_WINUSB_STATUS_SUCCESS)
 *   {
 *     return -1;
 *   }
 *
 *   while(1)
 *   {
 *     if ((bytes = USBD_WINUSB_BytesReceived(
 *     winusb_info.config.out_endpoint.Address)))
 *     {
 *       USBD_WINUSB_ReadData(winusb_info.config.out_endpoint.Address,&led,1);
 *
 *       USBD_WINUSB_WriteData(winusb_info.config.in_endpoint.Address,&led,1);
 *
 *     }
 *
 *   }
 *  return 0;
 * }
 *  @endcode
 */
USBD_WINUSB_Status_t USBD_WINUSB_Connect(void);


/**
 * @brief send \a length number of bytes of data to the USB host on selected endpoint \a ep_addr.
 * @param ep_addr Endpoint address including direction.
 * @param buffer Contains the data to be send.
 * @param length Length of the data to be send.
 * @return ::USBD_WINUSB_Status_t
 *
 * \par<b>Description:</b><br>
 *        In order to call USBD_WINUSB_WriteData()  following procedure should
 *        be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) USBD_WINUSB_Connect().\n
 *        3) Check the enumeration status by using ::USBD_WINUSB_IsEnumDone().\n
 *        4) After enumeration completion, call USBD_WINUSB_WriteData().\n
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   uint8_t led = 0;
 *   uint16_t bytes;
 *
 *   DAVE_Init();			// Initialization of DAVE APPs
 *
 *
 *   if (USBD_WINUSB_Connect() != USBD_WINUSB_STATUS_SUCCESS)
 *   {
 *     return -1;
 *   }
 *
 *   while(USBD_WINUSB_IsEnumDone()){}
 *
 *   while(1)
 *   {
 *     if ((bytes = USBD_WINUSB_BytesReceived(
 *     winusb_info.config.out_endpoint.Address)))
 *     {
 *       USBD_WINUSB_ReadData(winusb_info.config.out_endpoint.Address,&led,1);
 *
 *       USBD_WINUSB_WriteData(winusb_info.config.in_endpoint.Address,&led,1);
 *
 *     }
 *
 *   }
 *   return 0;
 * }
 *  @endcode
 */
USBD_WINUSB_Status_t USBD_WINUSB_WriteData(uint8_t ep_addr,
		const void *buffer,uint16_t length);

/**
 * @brief Reads \a length number of bytes of data from the USB host through endpoint \a ep_addr.
 * @param ep_addr Endpoint address including direction.
 * @param buffer User buffer to read the data into
 * @param length Length of the data to be read.
 * @return ::USBD_WINUSB_Status_t
 *
 * \par<b>Description:</b><br>
 *        In order to call USBD_WINUSB_ReadData()  following procedure should be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) Call ::USBD_WINUSB_Connect().\n
 *        3) Check the enumeration status by using ::USBD_WINUSB_IsEnumDone().\n
 *        4) Call ::USBD_WINUSB_BytesReceived().\n
 *        5) Call USBD_WINUSB_ReadData().\n
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   uint8_t led = 0;
 *   uint16_t bytes;
 *
 *   DAVE_Init();			// Initialization of DAVE APPs
 *
 *   if (USBD_WINUSB_Connect() != USBD_WINUSB_STATUS_SUCCESS)
 *   {
 *     return -1;
 *   }
 *
 *   while(USBD_WINUSB_IsEnumDone()){}
 *
 *   while(1)
 *   {
 *     if ((bytes = USBD_WINUSB_BytesReceived(
 *     winusb_info.config.out_endpoint.Address)))
 *     {
 *       USBD_WINUSB_ReadData(winusb_info.config.out_endpoint.Address,&led,1);
 *
 *       USBD_WINUSB_WriteData(winusb_info.config.in_endpoint.Address,&led,1);
 *     }
 *
 *  }
 *  return 0;
 * }
 *  @endcode
 */
USBD_WINUSB_Status_t USBD_WINUSB_ReadData(uint8_t ep_addr,void *buffer,
		uint16_t length);


/**
 * @brief Checks the number of bytes received from host and returns the same.
 * @param ep_addr endpoint address including direction.
 * @return uint16_t<br>
 *         The number of bytes recived on the selected OUT endpoint \a ep_addr.\n
 *
 * \par<b>Description:</b><br>
 * The function checks the number of bytes received on the selected OUT endpoint \a ep_addr.\n
 *       In order to call USBD_WINUSB_BytesReceived()  following procedure should be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) Call USBD_WINUSB_Connect().\n
 *        3) Check the enumeration status by using ::USBD_WINUSB_IsEnumDone().\n
 *        4) Call USBD_WINUSB_BytesReceived().\n
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   uint8_t led = 0;
 *   uint16_t bytes;
 *
 *   DAVE_Init();			// Initialization of DAVE APPs
 *
 *
 *   if (USBD_WINUSB_Connect() != USBD_WINUSB_STATUS_SUCCESS)
 *   {
 *     return -1;
 *   }
 *
 *   while(1)
 *   {
 *
 *     if ((bytes = USBD_WINUSB_BytesReceived(
 *     winusb_info.config.out_endpoint.Address)))
 *     {
 *       USBD_WINUSB_ReadData(winusb_info.config.out_endpoint.Address,&led,1);
 *
 *       USBD_WINUSB_WriteData(winusb_info.config.in_endpoint.Address,&led,1);
 *     }
 *
 *   }
 *   return 0;
 * }
 *  @endcode
 */
uint16_t USBD_WINUSB_BytesReceived(uint8_t ep_addr);


/**
 * @brief Configures the IN and OUT endpoints of WinUSB device based on ::USBD_WINUSB_Info_t Information.
 * @param winusb_info The pointer to WinUSB info structure ::USBD_WINUSB_Info_t.
 * @return uint8_t.
 *
 * \par<b>Description:</b><br>
 * This function should be called inside the USB device configuration change event callback.\n
 * In order to call USBD_WINUSB_ConfigureEndpoints(), following procedure should be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) Call USBD_WINUSB_Connect().\n
 *        3) Check the enumeration status by using ::USBD_WINUSB_IsEnumDone().\n
 *        4) Inside the USB device configuration change event callback, call ::USBD_SetEndpointBuffer() for \n
 *        each endpoint and then call USBD_WINUSB_ConfigureEndpoints().\n
 * Example Usage:
 * @code
 * #include <DAVE.h>
 * void WINUSB_Event_ConfigurationChanged(void);
 * int main(void)
 * {
 *   uint8_t led = 0;
 *   uint16_t bytes;
 *
 *   DAVE_Init();			// Initialization of DAVE APPs
 *
 *   if (USBD_WINUSB_Connect() != USBD_WINUSB_STATUS_SUCCESS)
 *   {
 *     return -1;
 *   }
 *
 *   while(1)
 *   {
 *     if ((bytes = USBD_WINUSB_BytesReceived(
 *     winusb_info.config.out_endpoint.Address)))
 *     {
 *       USBD_WINUSB_ReadData(winusb_info.config.out_endpoint.Address,&led,1);
 *
 *       USBD_WINUSB_WriteData(winusb_info.config.in_endpoint.Address,&led,1);
 *     }
 *
 *   }
 *  return 0;
 * }
 * void WINUSB_Event_ConfigurationChanged()
 * {
 *
 *   //set the endpoint buffers
 *
 *   //Call the API to configure the endpoints
 *   USBD_WINUSB_ConfigureEndpoints(&winusb_info);
 *
 *   device.IsConfigured = 1;
 *   USB_DeviceState = DEVICE_STATE_Configured;
 * }
 *  @endcode
 */
uint8_t USBD_WINUSB_ConfigureEndpoints(USBD_WINUSB_Info_t* const winusb_info);


/**
 * @brief Get USBD_WINUSB APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 *
 * @code
 * #include <DAVE.h>
 *
 * int main(void) {
 *
 *   DAVE_APP_VERSION_t version;
 *
 *   version = USBD_WINUSB_GetAppVersion();
 *   if (version.major != 4U) {
 *     // Probably, not the right version.
 *   }
 *
 *   // More code here
 *   while(1) {
 *
 *   }
 *   return (0);
 * }
 * @endcode<BR>
 */
DAVE_APP_VERSION_t USBD_WINUSB_GetAppVersion(void);

/**
 * @brief Disconnects the XMC USB device from WINUSB host.
 * @param None
 * @return ::USBD_WINUSB_Status_t
 *
 * \par<b>Description:</b><br>
 * In order to call USBD_WINUSB_Disconnect()  following procedure should be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) Call ::USBD_WINUSB_Connect().\n
 *        3) Check the enumeration status by using ::USBD_WINUSB_IsEnumDone().\n
 *        4) Call USBD_WINUSB_Disconnect().\n
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *
 *   DAVE_Init();			// Initialization of DAVE APPs
 *
 *
 *   if (USBD_WINUSB_Connect() != USBD_WINUSB_STATUS_SUCCESS)
 *   {
 *     return -1;
 *   }
 *   if (USBD_WINUSB_Disconnect() != USBD_WINUSB_STATUS_SUCCESS)
 *   {
 *   }
 *
 *   while(1)
 *   {
 *   }
 *   return 0;
 * }
 *  @endcode
 */
USBD_WINUSB_Status_t USBD_WINUSB_Disconnect(void);

/**
 * @brief Gets the enumeration completion status of USB device.
 * @param None
 * @return uint32_t<br>
 *         returns 1, if the enumeration is done. Returns 0 if the enumeration not yet complete.\n
 * \par<b>Description:</b><br>
 * In order to call USBD_WINUSB_IsEnumDone()  following procedure should be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) Connect USB device to host using ::USBD_WINUSB_Connect().\n
 *        3) USBD_WINUSB_IsEnumDone().\n
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *
 *   init_status = DAVE_Init();
 *
 *   if (init_status == DAVE_STATUS_SUCCESS)
 *   {
 *     if (USBD_WINUSB_Connect() != USBD_WINUSB_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *
 *     while(1U)
 *     {
 *       if (USBD_WINUSB_IsEnumDone())
 *       {
 *       }
 *     }
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 *  @endcode
 **/
  uint32_t USBD_WINUSB_IsEnumDone(void);

/**
* @}
*/

/*
* Registers the USB event callbacks with low level driver.
*/
USBD_WINUSB_Status_t USBD_WINUSB_Register_USBEvent_CB(USBD_Event_CB_t *event_callback);

/**
 * Event for USB configuration number changed. This event fires when a the USB host changes the selected configuration number.
 * This event should be hooked in device applications to create the endpoints and configure the device for the selected configuration.
 * This event is time-critical; exceeding OS-specific delays within this event handler (typically of around one second) will prevent
 * the device from enumerating correctly.
 *
 * This event fires after the value of configuration number has been changed.
 */
void USBD_WINUSB_Event_ConfigurationChanged(void);

/**
 * Event for control requests. This event fires when a the USB host issues a control request to the mandatory device control
 * endpoint (of address 0). This may either be a standard request that the library may have a handler code for internally,
 * or a class specific request issued to the device which must be handled appropriately. If a request is not processed in the
 * user application via this event, it will be passed to the library for processing internally if a suitable handler exists.
 *
 * This event is time-critical; each packet within the request transaction must be acknowledged or sent within 50ms or the host
 * will abort the transfer.
 *
 * The library internally handles all standard control requests with the exceptions of SYNC FRAME,  SET DESCRIPTOR and
 * SET INTERFACE. These and all other non-standard control requests will be left for the user to process via this event if desired.
 * If not handled in the user application or by the library internally, unknown requests are automatically STALLed.
 **/
void USBD_WINUSB_Event_ControlRequest(void);


/**
 * USB Get descriptor event handler. This function is called by the library when in device mode. When the device receives a
 * Get Descriptor request on the control endpoint, this function is called so that the descriptor details can be passed back
 * and the appropriate descriptor sent back to the USB host.
 * The user has to send proper descriptor(device,configuration and string) and should return the size of the descriptor data.
 **/
uint16_t USBD_WINUSB_Event_GetDescriptor(const uint16_t w_value,
									const uint16_t w_index,
									const void** const descriptor_address);

/**
 * Event for USB interface reset. This event fires when the USB interface is in device mode, and  the USB host requests that
 * the device reset its interface. This event fires after the control endpoint has been automatically configured by the library.
 *
 *  This event is time-critical; exceeding OS-specific delays within this event handler (typically of around  two seconds)
 *  will prevent the device from enumerating correctly.
 **/
void USBD_WINUSB_Event_Reset(void);

/*Disable C linkage for C++ Compilers: */
#if defined(__cplusplus)
	}
#endif

#endif

