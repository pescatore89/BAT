package Model.APPS.CCU8_SLICE_CONFIG.v4_0_22.Templates;

import Model.APPS.CCU8_SLICE_CONFIG.v4_0_22.CCU8_SLICE_CONFIG

out.print("""
/**
 * @file ccu8_slice_config_conf.c
 * @date 2018-05-24
 *
 * NOTE:
 * This file is generated by DAVE-4. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * 
 * Copyright (c) 2015-2017, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2016-02-05:
 *     - Initial version<br>
 * 2016-04-18:
 *     - Missing external event configuration on code generation is fixec<br>
 * 2016-04-29:
 *     - The ccu8_cc8_capture_ptr has been renamed to ccu8_cc8_slice_capture_ptr
 *       in the config structure<br>
 * 2016-06-21:
 *     - First productive version
 * 2017-03-17:
 *     - Fix channel output inversion control
 * 2017-04-04:
 *     - Add initialization of TLS
 * 2017-04-05:
 *     - Add initialization of timer value
 * 2017-04-11:
 *     - Generate initialization of input event independently of whether they are used for any timer function
 * 2017-11-10:
 *     - Fix C++ compilation issues
 * 2018-05-24:
 *     - Fix: setTimerValue() is only effective if it is called after enabling clk. 
 *
 * @endcond
 */ 

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "ccu8_slice_config.h"

""");

String    appInst                    = null;
List      MappedUri0                 = null;
String    module                     = null;
String    slice                      = null;
String    module_ptr                 = null;
String    slice_ptr                  = null;

for (CCU8_SLICE_CONFIG appIns : appInstancesList  )
{

	appInst = appIns.getInstanceLabel()
	MappedUri0 = appIns.hwres_ccu8_cc8_slice.getSolverUri()
		
	String series = (appIns.daveEnv.project.selectedDevice.deviceId.family + appIns.daveEnv.project.selectedDevice.deviceId.series)

	if (MappedUri0 != null)
	{
		module = MappedUri0[4]
		slice  = MappedUri0[6]
		module_ptr = "CCU8" + module
		slice_ptr = "CCU8" + module + "_CC8" + slice

		out.print("""
static CCU8_SLICE_CONFIG_STATUS_t ${appInst}_lInit(void);
        """)
		
		out.print("""
const CCU8_SLICE_CONFIG_t ${appInst} =
{
  .init = ${appInst}_lInit,
  .global = &${appIns.app_global_ccu8.getInstanceLabel()},
  .slice_ptr = ${slice_ptr},
  .slice_num = ${slice}
};
        """)
			
		if(appIns.gcombo_operation_mode.value == "Compare Mode")
		{			
			out.print("""
const XMC_CCU8_SLICE_COMPARE_CONFIG_t ${appInst}_compare_config     =
{
  .timer_mode            = XMC_CCU8_SLICE_TIMER_COUNT_MODE_${(appIns.gcombo_compare_counting_mode.value == "Edge Aligned") ? "EA" : "CA"},
  .monoshot              = XMC_CCU8_SLICE_TIMER_REPEAT_MODE_${appIns.gcheck_single_shot_mode.value ? "SINGLE" : "REPEAT"},
  .shadow_xfer_clear     = ${appIns.gcheck_enable_shadow_transfer_on_clear.value ? "true" : "false"},
  .dither_timer_period   = ${((appIns.gcombo_dither_mode.value == "Period is increased by 1 cycle") || 
                              (appIns.gcombo_dither_mode.value == "Period is increased by 1 cycle and compare match is delayed by 1 cycle")) ? "true" : "false"},
  .dither_duty_cycle     = ${((appIns.gcombo_dither_mode.value == "Compare match is delayed by 1 cycle") || 
                              (appIns.gcombo_dither_mode.value == "Period is increased by 1 cycle and compare match is delayed by 1 cycle")) ? "true" : "false"},
  .prescaler_mode        = XMC_CCU8_SLICE_PRESCALER_MODE_${(appIns.gcombo_prescaler_mode.value == "Normal Mode") ? "NORMAL" : "FLOAT"},  
  .mcm_ch1_enable        = ${((appIns.gcombo_multi_channel_control.value == "Applied on compare channel 1") || (appIns.gcombo_multi_channel_control.value == "Applied on both compare channels")) ? "true" : "false"},        
  .mcm_ch2_enable        = ${((appIns.gcombo_multi_channel_control.value == "Applied on compare channel 2") || (appIns.gcombo_multi_channel_control.value == "Applied on both compare channels")) ? "true" : "false"},
  .slice_status          = XMC_CCU8_SLICE_STATUS_CHANNEL_${
                             def result
                             switch(appIns.gcombo_status_output.value)
                             {
                               case "Compare channel 1":
                               result = "1"
                               break;

                               case "Compare channel 2":
                               result = "2"
                               break;

                               case "Compare channel 1 AND 2":
                               result = "1_AND_2"
                               break;

                               case "Compare channel 1 OR 2":
                               result = "1_OR_2"
                               break;
                             }
                             result
                           },
  .prescaler_initval     = XMC_CCU8_SLICE_PRESCALER_${appIns.gcombo_prescaler_initial.value},
  .float_limit           = XMC_CCU8_SLICE_PRESCALER_${appIns.gcombo_floating_prescaler_maximum.value},
  .dither_limit          = ${appIns.ginteger_dither_compare_value.value},
  .passive_level_out0    = XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_${(appIns.gcombo_output0_passive_level.value == "Low") ? "LOW" : "HIGH"},  
  .passive_level_out1    = XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_${(appIns.gcombo_output1_passive_level.value == "Low") ? "LOW" : "HIGH"},  
  .passive_level_out2    = XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_${(appIns.gcombo_output2_passive_level.value == "Low") ? "LOW" : "HIGH"},  
  .passive_level_out3    = XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_${(appIns.gcombo_output3_passive_level.value == "Low") ? "LOW" : "HIGH"},
  .asymmetric_pwm        = ${appIns.gcheck_asymmetric_output.value ? "true" : "false"},
            ${
               def result
               if (series != 'XMC14') {
                 result = """
  .invert_out0           = ${(appIns.gcombo_output0_st.value == "Inverted ST1") ? "true" : "false"},
  .invert_out1           = ${(appIns.gcombo_output1_st.value == "Inverted ST1") ? "true" : "false"}, 
  .invert_out2           = ${(appIns.gcombo_output2_st.value == "Inverted ST2") ? "true" : "false"},
  .invert_out3           = ${(appIns.gcombo_output3_st.value == "Inverted ST2") ? "true" : "false"},
                 """
               }
               else {
                 def output0_st
                 switch(appIns.gcombo_output0_st.value)
                 {
                   case "ST1":
                     output0_st = "ST1"
                     break
 
                   case "Inverted ST1":
                     output0_st = "INV_ST1"
                     break
 
                   case "ST2":
                     output0_st = "ST2"
                     break
        
                   case "Inverted ST2":
                     output0_st = "INV_ST2"
                     break
                 }

                 def output1_st
                 switch(appIns.gcombo_output1_st.value)
                 {
                   case "ST1":
                     output1_st = "ST1"
                     break
 
                   case "Inverted ST1":
                     output1_st = "INV_ST1"
                     break
 
                   case "ST2":
                     output1_st = "ST2"
                     break
        
                   case "Inverted ST2":
                     output1_st = "INV_ST2"
                     break
                 }

                 def output2_st
                 switch(appIns.gcombo_output2_st.value)
                 {
                   case "ST1":
                     output2_st = "ST1"
                     break
 
                   case "Inverted ST1":
                     output2_st = "INV_ST1"
                     break
 
                   case "ST2":
                     output2_st = "ST2"
                     break
        
                   case "Inverted ST2":
                     output2_st = "INV_ST2"
                     break
                 }

                 def output3_st
                 switch(appIns.gcombo_output3_st.value)
                 {
                   case "ST1":
                     output3_st = "ST1"
                     break
 
                   case "Inverted ST1":
                     output3_st = "INV_ST1"
                     break
 
                   case "ST2":
                     output3_st = "ST2"
                     break
        
                   case "Inverted ST2":
                     output3_st = "INV_ST2"
                     break
                 }

                 result = """
  .selector_out0         = XMC_CCU8_SOURCE_OUT0_${output0_st},
  .selector_out1         = XMC_CCU8_SOURCE_OUT1_${output1_st},
  .selector_out2         = XMC_CCU8_SOURCE_OUT2_${output2_st},
  .selector_out3         = XMC_CCU8_SOURCE_OUT3_${output3_st},
                 """
               }
               result
             }
  .timer_concatenation   = ${appIns.hwres_ccu8_cc8_slice.getRegValue("cmc", "cmc_tce") ? "true" : "false"}
};
            """)
			if(appIns.gcheck_enable_dead_time_channel1.value || appIns.gcheck_enable_dead_time_channel1.value)
			{
 			  out.print("""
const XMC_CCU8_SLICE_DEAD_TIME_CONFIG_t ${appInst}_dead_time_config =
{
  .enable_dead_time_channel1 = ${appIns.gcheck_enable_dead_time_channel1.value ? "true" : "false"},
  .enable_dead_time_channel2 = ${appIns.gcheck_enable_dead_time_channel2.value ? "true" : "false"},
  .channel1_st_path = ${appIns.gcheck_enable_dead_time_channel1.value ? "true" : "false"},
  .channel1_inv_st_path = ${appIns.gcheck_enable_dead_time_channel1.value ? "true" : "false"},
  .channel2_st_path = ${appIns.gcheck_enable_dead_time_channel2.value ? "true" : "false"},
  .channel2_inv_st_path = ${appIns.gcheck_enable_dead_time_channel2.value ? "true" : "false"},
  .div = XMC_CCU8_SLICE_DTC_DIV_${appIns.gcombo_dead_time_clock_divider.value},
  .channel1_st_rising_edge_counter = ${appIns.ginteger_channel1_dead_time_passive_active.value},
  .channel1_st_falling_edge_counter = ${appIns.ginteger_channel1_dead_time_active_passive.value},
  .channel2_st_rising_edge_counter = ${appIns.ginteger_channel2_dead_time_passive_active.value},
  .channel2_st_falling_edge_counter = ${appIns.ginteger_channel2_dead_time_active_passive.value},
};
              """)				
			}
			
			
		} // Compare mode
		else
		{
			out.print("""
const XMC_CCU8_SLICE_CAPTURE_CONFIG_t  ${appInst}_capture_config     =
{ 
  .fifo_enable           = ${appIns.gcheck_enable_extended_capture_mode.value ? "true" : "false"},
  .timer_clear_mode      = XMC_CCU8_SLICE_TIMER_CLEAR_MODE_${
                             def result
                             switch(appIns.gcombo_timer_clear_control.value)
                             {
                               case "Never cleared":
                                 result = "NEVER"
                                 break
                               case "Cleared on capture into reg 2 and 3 (trigger 1)":
                                 result = "CAP_HIGH"
                                 break
                               case "Cleared on capture into reg 0 and 1 (trigger 0)":
                                 result = "CAP_LOW"
                                 break
                               case "Always in a capture event":
                                 result = "ALWAYS"
                                 break
                             }
                             result
                           },
  .same_event			 = ${appIns.gcheck_enable_same_capture_event.value ? "true" : "false"},
  .ignore_full_flag      = ${appIns.gcheck_ignore_full_flag_rules.value ? "true" : "false"},
  .prescaler_mode        = XMC_CCU8_SLICE_PRESCALER_MODE_${(appIns.gcombo_prescaler_mode.value == "Normal Mode") ? "NORMAL" : "FLOAT"},  
  .prescaler_initval     = XMC_CCU8_SLICE_PRESCALER_${appIns.gcombo_prescaler_initial.value},
  .float_limit           = XMC_CCU8_SLICE_PRESCALER_${appIns.gcombo_floating_prescaler_maximum.value},
  .timer_concatenation   = ${appIns.hwres_ccu8_cc8_slice.getRegValue("cmc", "cmc_tce") ? "true" : "false"}
};
            """)
		} // Capture mode
			
		// Events
		for (int event = 0; event < 3; event++)
		{
			def mapped_input
			def event_is
			event_is = "ins_ev"+event+"is"
			if (series != 'XMC14')
			{
			  mapped_input = "XMC_CCU8_SLICE_INPUT_${(char)(appIns.hwres_ccu8_cc8_slice.getRegValue("ins", event_is) + 65)}"
			}
			else
			{
			  mapped_input = "XMC_CCU8_SLICE_INPUT_${(char)(((appIns.hwres_ccu8_cc8_slice.getRegValue("ins", event_is) as int) / 26) + 65)}${(char)(((appIns.hwres_ccu8_cc8_slice.getRegValue("ins", event_is) as int) % 26) + 65)}"
			}

			out.print("""
const XMC_CCU8_SLICE_EVENT_CONFIG_t ${appInst}_event${event}_config = 
{
  .mapped_input        = ${mapped_input},
  .edge                = XMC_CCU8_SLICE_EVENT_EDGE_SENSITIVITY_${
                             def result
                             switch(appIns.rArraygindexgroup_input_event_configuration[event].gcombo_event_edge_selection.value)
                             {
                               case "No action":
                                 result = "NONE"
                                 break
                               case "Signal active on rising edge":
                                 result = "RISING_EDGE"
                                 break
                               case "Signal active on falling edge":
                                 result = "FALLING_EDGE"
                                 break
                               case "Signal active on both edges":
                                 result = "DUAL_EDGE"
                                 break
                             }
                           },
  .level               = XMC_CCU8_SLICE_EVENT_LEVEL_SENSITIVITY_${
                             def result
                             switch(appIns.rArraygindexgroup_input_event_configuration[event].gcombo_event_level_selection.value)
                             {
                               case "Active on high level":
                                 result = "ACTIVE_HIGH"
                                 break
                               case "Active on low level":
                                 result = "ACTIVE_LOW"
                                 break
                             } 
                             result
                           },
  .duration            = XMC_CCU8_SLICE_EVENT_FILTER_${
                             def result
                             switch(appIns.rArraygindexgroup_input_event_configuration[event].gcombo_event_lpf_configuration.value)
                             {
                               case "LPF is disabled":
                                 result = "DISABLED"
                                 break
                               case "3 clock cycles of fCCU8":
                                 result = "3_CYCLES"
                                 break
                               case "5 clock cycles of fCCU8":
                                 result = "5_CYCLES"
                                 break
                               case "7 clock cycles of fCCU8":
                                 result = "7_CYCLES"
                                 break
                             } 
                             result
                           }                               
 };
            """)
		}
	}
	else
	{
		out.print("""
  /*CCU80 resource is not mapped for CCU8_SLICE_CONFIG app instant: ${appInst} */
        """);
	}
	
	out.print("""
/* Channel initialization function */
CCU8_SLICE_CONFIG_STATUS_t ${appInst}_lInit(void)
{
 	
  (void)GLOBAL_CCU8_Init(&${appIns.app_global_ccu8.getInstanceLabel()});

  ${
    def result
    if(appIns.gcombo_operation_mode.value == "Compare Mode")
    {
      result = """ 
  /* Configure CCU8x_CC8y slice as timer unit*/
  XMC_CCU8_SLICE_CompareInit(${slice_ptr}, &${appInst}_compare_config);

  /* Set timer compare register value */
  XMC_CCU8_SLICE_SetTimerCompareMatchChannel1(${slice_ptr}, (uint16_t)${appIns.ginteger_timer_compare1_value.value}U); 
  XMC_CCU8_SLICE_SetTimerCompareMatchChannel2(${slice_ptr}, (uint16_t)${appIns.ginteger_timer_compare2_value.value}U); 
  /* Set timer period register value */
  XMC_CCU8_SLICE_SetTimerPeriodMatch(${slice_ptr}, (uint16_t)${appIns.ginteger_timer_period_value.value}U);	
	  """
    }
    else
    {
      result = """
  /* Configure CCU8x_CC8y slice as capture unit*/
  XMC_CCU8_SLICE_CaptureInit(${slice_ptr}, &${appInst}_capture_config);
  /* Set timer period register value */
  XMC_CCU8_SLICE_SetTimerPeriodMatch(${slice_ptr}, (uint16_t)${appIns.ginteger_max_count_value.value}U);	
	  """
    }
    result
  }

  ${
    def result = ""
   	if(appIns.gcheck_enable_dead_time_channel1.value || appIns.gcheck_enable_dead_time_channel1.value)
    {
      result = """
  /* Configure dead time */		  
  XMC_CCU8_SLICE_DeadTimeInit(${slice_ptr}, &${appInst}_dead_time_config);	  
	  """
    }
    result
  }
  
  /* Register value update settings */
  ${
    def result = ""
    if (appIns.gcheck_enable_mcss_input.value)
    {
      result = """
  XMC_CCU8_SetMultiChannelShadowTransferMode(${module_ptr}, XMC_CCU8_MULTI_CHANNEL_SHADOW_TRANSFER_SW_MCSS_SLICE${slice});
			   """
    }
    else
    {
      result = """
  XMC_CCU8_SetMultiChannelShadowTransferMode(${module_ptr}, XMC_CCU8_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE${slice});
			   """
    }
    result
  }

  ${
    def result = ""
    if (series != 'XMC45')
    {
      if (appIns.gcheck_enable_cascade_shadow_transfer.value)
      {
        result = """
  XMC_CCU8_SLICE_EnableCascadedShadowTransfer(${slice_ptr});
		"""
      }
      else
      {
        result = """
  XMC_CCU8_SLICE_DisableCascadedShadowTransfer(${slice_ptr});
		"""
      }
    }
    result
  }

  ${
    def result = ""
    if (series != 'XMC45')
    {
      if (appIns.gcombo_compare_counting_mode.value == "Center Aligned")
      {
        result = """
  XMC_CCU8_SLICE_SetShadowTransferMode(${slice_ptr}, XMC_CCU8_SLICE_SHADOW_TRANSFER_MODE_${appIns.gcombo_shadow_transfer_mode.value.toUpperCase().replaceAll(' ', '_')});
	    """
      }
    }
    result
  }

  ${
    def result = ""
    if (series == 'XMC14')
    {
      def mask = []
      if (appIns.gcheck_enable_period_immediate_update.value)
      {
        mask += "XMC_CCU8_SLICE_WRITE_INTO_PERIOD_CONFIGURATION"
      }
      if (appIns.gcheck_enable_compare1_immediate_update.value)
      {
        mask += "XMC_CCU8_SLICE_WRITE_INTO_COMPARE1_CONFIGURATION"
      }
      if (appIns.gcheck_enable_compare2_immediate_update.value)
      {
        mask += "XMC_CCU8_SLICE_WRITE_INTO_COMPARE2_CONFIGURATION"
      }
      if (appIns.gcheck_enable_psl_immediate_update.value)
      {
        mask += "XMC_CCU8_SLICE_WRITE_INTO_PASSIVE_LEVEL_CONFIGURATION"
      }
      if (appIns.gcheck_enable_dither_immediate_update.value)
      {
        mask += "XMC_CCU8_SLICE_WRITE_INTO_DITHER_VALUE_CONFIGURATION"
      }
      if (appIns.gcheck_enable_prescaler_immediate_update.value)
      {
        mask += "XMC_CCU8_SLICE_WRITE_INTO_FLOATING_PRESCALER_VALUE_CONFIGURATION"
      }
      if (mask.size() > 0)
      {
        result = """
  XMC_CCU8_SLICE_WriteImmediateAfterShadowTransfer(${slice_ptr}, ${mask.join(" | ")});
	    """
      }
    }
    result
  }

  ${
    def result = ""
    if (series == 'XMC14')
    {
      def mask = []
      if (appIns.gcheck_automatic_shadow_transfer_request_on_period_write.value)
      {
        mask += "XMC_CCU8_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_PERIOD_SHADOW"
      }
      if (appIns.gcheck_automatic_shadow_transfer_request_on_compare1_write.value)
      {
        mask += "XMC_CCU8_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_COMPARE1_SHADOW"
      }
      if (appIns.gcheck_automatic_shadow_transfer_request_on_compare2_write.value)
      {
        mask += "XMC_CCU8_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_COMPARE2_SHADOW"
      }
      if (appIns.gcheck_automatic_shadow_transfer_request_on_psl_write.value)
      {
        mask += "XMC_CCU8_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_PASSIVE_LEVEL"
      }
      if (appIns.gcheck_automatic_shadow_transfer_request_on_dither_write.value)
      {
        mask += "XMC_CCU8_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_DITHER_SHADOW"
      }
      if (appIns.gcheck_automatic_shadow_transfer_request_on_prescaler_write.value)
      {
        mask += "XMC_CCU8_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_FLOATING_PRESCALER_SHADOW"
      }
      if (mask.size() > 0)
      {
        result = """
  XMC_CCU8_SLICE_EnableAutomaticShadowTransferRequest(${slice_ptr}, ${mask.join(" | ")});
	    """
      }
    }
    result
  }

  /* Transfer value from shadow registers to actual timer registers */
  XMC_CCU8_EnableShadowTransfer(${module_ptr}, XMC_CCU8_SHADOW_TRANSFER_SLICE_${slice} |
                                               XMC_CCU8_SHADOW_TRANSFER_DITHER_SLICE_${slice} |
                                               XMC_CCU8_SHADOW_TRANSFER_PRESCALER_SLICE_${slice});

  /* Events and function settings */
  ${
    def result = ""
    for (int event = 0; event < 3; event++)
    {
        result += """
  XMC_CCU8_SLICE_ConfigureEvent(${slice_ptr}, XMC_CCU8_SLICE_EVENT_${event}, &${appInst}_event${event}_config);
		"""
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_start_function.value != "Disabled")
    {
      def event = "XMC_CCU8_SLICE_EVENT_" + appIns.gcombo_start_function.value[-1]
      def mode = "XMC_CCU8_SLICE_START_MODE_TIMER_"
      switch(appIns.gcombo_start_function_mode.value)
      {
        case "Start timer":
          mode += "START"
          break
        case "Clear and Start timer":
          mode += "START_CLEAR"
          break
      }
      result = """
  XMC_CCU8_SLICE_StartConfig(${slice_ptr}, ${event}, ${mode});
	  """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_stop_function.value != "Disabled")
    {
      def event = "XMC_CCU8_SLICE_EVENT_" + appIns.gcombo_stop_function.value[-1]
      def mode = "XMC_CCU8_SLICE_END_MODE_TIMER_"
      switch(appIns.gcombo_stop_function_mode.value)
      {
        case "Stop timer":
          mode += "STOP"
          break
        case "Clear timer":
          mode += "CLEAR"
          break
        case "Clear and Stop timer":
          mode += "STOP_CLEAR"
          break
      }
      result = """
  XMC_CCU8_SLICE_StopConfig(${slice_ptr}, ${event}, ${mode});
	  """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_count_function.value != "Disabled")
    {
      def event = "XMC_CCU8_SLICE_EVENT_" + appIns.gcombo_count_function.value[-1]
      result = """
  XMC_CCU8_SLICE_CountConfig(${slice_ptr}, ${event});
	  """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_direction_function.value != "Disabled")
    {
      def event = "XMC_CCU8_SLICE_EVENT_" + appIns.gcombo_direction_function.value[-1]
      result = """
  XMC_CCU8_SLICE_DirectionConfig(${slice_ptr}, ${event});
	  """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_capture0_function.value != "Disabled")
    {
      def event = "XMC_CCU8_SLICE_EVENT_" + appIns.gcombo_capture0_function.value[-1]
      result = """
  XMC_CCU8_SLICE_Capture0Config(${slice_ptr}, ${event});
	  """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_capture1_function.value != "Disabled")
    {
      def event = "XMC_CCU8_SLICE_EVENT_" + appIns.gcombo_capture1_function.value[-1]
      result = """
  XMC_CCU8_SLICE_Capture1Config(${slice_ptr}, ${event});
	  """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_gate_function.value != "Disabled")
    {
      def event = "XMC_CCU8_SLICE_EVENT_" + appIns.gcombo_gate_function.value[-1]
      result = """
  XMC_CCU8_SLICE_GateConfig(${slice_ptr}, ${event});
	  """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_load_function.value != "Disabled")
    {
      def event = "XMC_CCU8_SLICE_EVENT_" + appIns.gcombo_load_function.value[-1]
      def channel = "XMC_CCU8_SLICE_COMPARE_CHANNEL_"
      switch(appIns.gcombo_load_function_mode.value)
      {
        case "Timer is loaded with the value of CR1":
          channel += "1"
          break
        case "Timer is loaded with the value of CR2":
          channel += "2"
          break
      }

      result = """
  XMC_CCU8_SLICE_LoadConfig(${slice_ptr}, ${event});
  XMC_CCU8_SLICE_LoadSelector(${slice_ptr}, ${channel});
	  """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_trap_function.value != "Disabled")
    {
      def args
      switch(appIns.gcombo_exit_trap_state_mode.value)
      {
        case "Automatic":
          args = "XMC_CCU8_SLICE_TRAP_EXIT_MODE_AUTOMATIC, false"
          break
        case "Automatic synchronous with PWM":
          args = "XMC_CCU8_SLICE_TRAP_EXIT_MODE_AUTOMATIC, true"
          break
        case "Software":
          args = "XMC_CCU8_SLICE_TRAP_EXIT_MODE_SW, false"
          break
        case "Software synchronous with PWM ":
          args = "XMC_CCU8_SLICE_TRAP_EXIT_MODE_SW, true"
          break

      }
      def event = "XMC_CCU8_SLICE_EVENT_" + appIns.gcombo_trap_function.value[-1]
      result = """
  XMC_CCU8_SLICE_TrapConfig(${slice_ptr}, ${args});
	  """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_modulation_function.value != "Disabled")
    {
      def event = "XMC_CCU8_SLICE_EVENT_" + appIns.gcombo_modulation_function.value[-1]

      def args
      switch(appIns.gcombo_modulation_function_mode.value)
      {
        case "Clear ST and OUT signals":
          args = " XMC_CCU8_SLICE_MODULATION_MODE_CLEAR_ST_OUT, "
          break
        case "Clear only the OUT signal":
          args = " XMC_CCU8_SLICE_MODULATION_MODE_CLEAR_OUT, "
          break
      }

      switch(appIns.gcombo_modulation_channel.value)
      {
        case "None":
          args += "XMC_CCU8_SLICE_MODULATION_CHANNEL_NONE, "
          break
        case "Channel 1":
          args += "XMC_CCU8_SLICE_MODULATION_CHANNEL_1, "
          break
        case "Channel 2":
          args += "XMC_CCU8_SLICE_MODULATION_CHANNEL_2, "
          break
        case "Both channels":
          args += "XMC_CCU8_SLICE_MODULATION_CHANNEL_1_AND_2, "
          break
      }

      if (appIns.gcheck_enable_modulation_sync_with_pwm.value)
      {
        args += "true"
      }
      else
      {
        args += "false"
      }

      result = """
  XMC_CCU8_SLICE_ModulationConfig(${slice_ptr}, ${event}, ${args});
	  """
    }
    result
  }
  
  ${
    def result = ""
    if(appIns.gcombo_override_trigger_function.value != "Disabled" && appIns.gcombo_override_value_function.value != "Disabled")
    {
      result = """
  XMC_CCU8_SLICE_StatusBitOverrideConfig(${slice_ptr});
			   """
    }
    result
  }

  ${
    def mask = []
    def result = ""
    if(appIns.gcheck_enable_period_match_event.value) 
    {
      mask.add("XMC_CCU8_SLICE_MULTI_IRQ_ID_PERIOD_MATCH")
      result += """
  XMC_CCU8_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH, XMC_CCU8_SLICE_SR_ID_${appIns.hwres_ccu8_cc8_slice.getRegValue("srs", "srs_posr")});
	  """
    }

    if(appIns.gcheck_enable_one_match_event.value) 
    {
      mask.add("XMC_CCU8_SLICE_MULTI_IRQ_ID_ONE_MATCH")
      result += """
  XMC_CCU8_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU8_SLICE_IRQ_ID_ONE_MATCH, XMC_CCU8_SLICE_SR_ID_${appIns.hwres_ccu8_cc8_slice.getRegValue("srs", "srs_posr")});
	  """
    }

    if(appIns.gcheck_enable_compare1_up_event.value) 
    {
      mask.add("XMC_CCU8_SLICE_MULTI_IRQ_ID_COMPARE_MATCH_UP_CH_1")
      result += """
  XMC_CCU8_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1, XMC_CCU8_SLICE_SR_ID_${appIns.hwres_ccu8_cc8_slice.getRegValue("srs", "srs_cm1sr")});
	  """
    }

    if(appIns.gcheck_enable_compare1_down_event.value) 
    {
      mask.add("XMC_CCU8_SLICE_MULTI_IRQ_ID_COMPARE_MATCH_DOWN_CH_1")
      result += """
  XMC_CCU8_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1, XMC_CCU8_SLICE_SR_ID_${appIns.hwres_ccu8_cc8_slice.getRegValue("srs", "srs_cm1sr")});
	  """
    }

    if(appIns.gcheck_enable_compare2_up_event.value) 
    {
      mask.add("XMC_CCU8_SLICE_MULTI_IRQ_ID_COMPARE_MATCH_UP_CH_2")
      result += """
  XMC_CCU8_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2, XMC_CCU8_SLICE_SR_ID_${appIns.hwres_ccu8_cc8_slice.getRegValue("srs", "srs_cm2sr")});
	  """
    }

    if(appIns.gcheck_enable_compare2_down_event.value) 
    {
      mask.add("XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2")
      result += """
  XMC_CCU8_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2, XMC_CCU8_SLICE_SR_ID_${appIns.hwres_ccu8_cc8_slice.getRegValue("srs", "srs_cm2sr")});
	  """
    }

    if(appIns.gcheck_enable_external_event0.value) 
    {
      mask.add("XMC_CCU8_SLICE_MULTI_IRQ_ID_EVENT0")
      result += """
  XMC_CCU8_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU8_SLICE_IRQ_ID_EVENT0, XMC_CCU8_SLICE_SR_ID_${appIns.hwres_ccu8_cc8_slice.getRegValue("srs", "srs_e0sr")});
	  """
    }

    if(appIns.gcheck_enable_external_event1.value) 
    {
      mask.add("XMC_CCU8_SLICE_MULTI_IRQ_ID_EVENT1")
      result += """
  XMC_CCU8_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU8_SLICE_IRQ_ID_EVENT1, XMC_CCU8_SLICE_SR_ID_${appIns.hwres_ccu8_cc8_slice.getRegValue("srs", "srs_e1sr")});
	  """
    }

    if(appIns.gcheck_enable_external_event2.value) 
    {
      mask.add("XMC_CCU8_SLICE_MULTI_IRQ_ID_EVENT2")
      result += """
  XMC_CCU8_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU8_SLICE_IRQ_ID_EVENT2, XMC_CCU8_SLICE_SR_ID_${appIns.hwres_ccu8_cc8_slice.getRegValue("srs", "srs_e2sr")});
	  """
    }
   if (mask.size() > 0)
   {
     result += """
  XMC_CCU8_SLICE_EnableMultipleEvents(${slice_ptr}, ${mask.join(" | ")});
	 """
   }
   result
  }
			
  /* clear IDLE mode for the slice*/
  XMC_CCU8_EnableClock(${module_ptr}, ${slice});	

  /* Set initial value of timer */
  XMC_CCU8_SLICE_SetTimerValue(${slice_ptr}, (uint16_t)${appIns.ginteger_timer_initial_value.value}U);
	
  ${
    def result = ""
    if(appIns.gcheck_enable_trap_during_initialization.value) 
    {
      def mask = []
      if(appIns.gcheck_trap_out00.value) 
      {
        mask.add("XMC_CCU8_SLICE_OUTPUT_0")
      }
      if(appIns.gcheck_trap_out01.value) 
      {
        mask.add("XMC_CCU8_SLICE_OUTPUT_1")
      }
      if(appIns.gcheck_trap_out02.value) 
      {
        mask.add("XMC_CCU8_SLICE_OUTPUT_2")
      }
      if(appIns.gcheck_trap_out03.value) 
      {
        mask.add("XMC_CCU8_SLICE_OUTPUT_3")
      }

      if (mask.size() > 0)
      {
        result = """ 
  /* Enable trap */
  XMC_CCU8_SLICE_EnableTrap(${slice_ptr}, ${mask.join(" | ")});
	    """
      }
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcheck_init_start.value) 
    {
      result = """ 
  /* Start the timer */
  XMC_CCU8_SLICE_StartTimer(${slice_ptr});
	  """
    }
    result
  }

  return CCU8_SLICE_CONFIG_STATUS_SUCCESS;
}
	""".replaceAll("(?m)^\r?\n", ""))
} // for
